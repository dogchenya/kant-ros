// **********************************************************************
// This file was generated by a KANT parser!
// KANT version KANT_VERSION.
// **********************************************************************

#ifndef __NODEDESCRIPTOR_H_
#define __NODEDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Kant.h"
#include "tup/KantJson.h"
using namespace std;


namespace kant
{
    enum ServerState
    {
        Inactive,
        Activating,
        Active,
        Deactivating,
        Destroying,
        Destroyed,
    };
    inline string etos(const ServerState & e)
    {
        switch(e)
        {
            case Inactive: return "Inactive";
            case Activating: return "Activating";
            case Active: return "Active";
            case Deactivating: return "Deactivating";
            case Destroying: return "Destroying";
            case Destroyed: return "Destroyed";
            default: return "";
        }
    }
    inline int stoe(const string & s, ServerState & e)
    {
        if(s == "Inactive")  { e=Inactive; return 0;}
        if(s == "Activating")  { e=Activating; return 0;}
        if(s == "Active")  { e=Active; return 0;}
        if(s == "Deactivating")  { e=Deactivating; return 0;}
        if(s == "Destroying")  { e=Destroying; return 0;}
        if(s == "Destroyed")  { e=Destroyed; return 0;}

        return -1;
    }

    struct LoadInfo : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.LoadInfo";
        }
        static string MD5()
        {
            return "2daf1c7301b9d722a2e5cbcf1e08a5c1";
        }
        LoadInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            avg1 = 0;
            avg5 = 0;
            avg15 = 0;
            avgCpu = 0;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(avg1, 0);
            _os.write(avg5, 1);
            _os.write(avg15, 2);
            if (avgCpu != 0)
            {
                _os.write(avgCpu, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(avg1, 0, true);
            _is.read(avg5, 1, true);
            _is.read(avg15, 2, true);
            _is.read(avgCpu, 3, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["avg1"] = kant::JsonOutput::writeJson(avg1);
            p->value["avg5"] = kant::JsonOutput::writeJson(avg5);
            p->value["avg15"] = kant::JsonOutput::writeJson(avg15);
            p->value["avgCpu"] = kant::JsonOutput::writeJson(avgCpu);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(avg1,pObj->value["avg1"], true);
            kant::JsonInput::readJson(avg5,pObj->value["avg5"], true);
            kant::JsonInput::readJson(avg15,pObj->value["avg15"], true);
            kant::JsonInput::readJson(avgCpu,pObj->value["avgCpu"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(avg1,"avg1");
            _ds.display(avg5,"avg5");
            _ds.display(avg15,"avg15");
            _ds.display(avgCpu,"avgCpu");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(avg1, true);
            _ds.displaySimple(avg5, true);
            _ds.displaySimple(avg15, true);
            _ds.displaySimple(avgCpu, false);
            return _os;
        }
    public:
        kant::Float avg1;
        kant::Float avg5;
        kant::Float avg15;
        kant::Int32 avgCpu;
    };
    inline bool operator==(const LoadInfo&l, const LoadInfo&r)
    {
        return kant::KT_Common::equal(l.avg1,r.avg1) && kant::KT_Common::equal(l.avg5,r.avg5) && kant::KT_Common::equal(l.avg15,r.avg15) && l.avgCpu == r.avgCpu;
    }
    inline bool operator!=(const LoadInfo&l, const LoadInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const LoadInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,LoadInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PatchInfo : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.PatchInfo";
        }
        static string MD5()
        {
            return "08dafd74f4acfa70d049987efbf7c0f2";
        }
        PatchInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            bPatching = false;
            iPercent = 0;
            iModifyTime = 0;
            sVersion = "";
            sResult = "";
            bSucc = false;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(bPatching, 0);
            _os.write(iPercent, 1);
            _os.write(iModifyTime, 2);
            _os.write(sVersion, 3);
            _os.write(sResult, 4);
            if (bSucc != false)
            {
                _os.write(bSucc, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bPatching, 0, true);
            _is.read(iPercent, 1, true);
            _is.read(iModifyTime, 2, true);
            _is.read(sVersion, 3, true);
            _is.read(sResult, 4, true);
            _is.read(bSucc, 5, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["bPatching"] = kant::JsonOutput::writeJson(bPatching);
            p->value["iPercent"] = kant::JsonOutput::writeJson(iPercent);
            p->value["iModifyTime"] = kant::JsonOutput::writeJson(iModifyTime);
            p->value["sVersion"] = kant::JsonOutput::writeJson(sVersion);
            p->value["sResult"] = kant::JsonOutput::writeJson(sResult);
            p->value["bSucc"] = kant::JsonOutput::writeJson(bSucc);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(bPatching,pObj->value["bPatching"], true);
            kant::JsonInput::readJson(iPercent,pObj->value["iPercent"], true);
            kant::JsonInput::readJson(iModifyTime,pObj->value["iModifyTime"], true);
            kant::JsonInput::readJson(sVersion,pObj->value["sVersion"], true);
            kant::JsonInput::readJson(sResult,pObj->value["sResult"], true);
            kant::JsonInput::readJson(bSucc,pObj->value["bSucc"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(bPatching,"bPatching");
            _ds.display(iPercent,"iPercent");
            _ds.display(iModifyTime,"iModifyTime");
            _ds.display(sVersion,"sVersion");
            _ds.display(sResult,"sResult");
            _ds.display(bSucc,"bSucc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(bPatching, true);
            _ds.displaySimple(iPercent, true);
            _ds.displaySimple(iModifyTime, true);
            _ds.displaySimple(sVersion, true);
            _ds.displaySimple(sResult, true);
            _ds.displaySimple(bSucc, false);
            return _os;
        }
    public:
        kant::Bool bPatching;
        kant::Int32 iPercent;
        kant::Int32 iModifyTime;
        std::string sVersion;
        std::string sResult;
        kant::Bool bSucc;
    };
    inline bool operator==(const PatchInfo&l, const PatchInfo&r)
    {
        return l.bPatching == r.bPatching && l.iPercent == r.iPercent && l.iModifyTime == r.iModifyTime && l.sVersion == r.sVersion && l.sResult == r.sResult && l.bSucc == r.bSucc;
    }
    inline bool operator!=(const PatchInfo&l, const PatchInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PatchInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PatchInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct NodeInfo : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.NodeInfo";
        }
        static string MD5()
        {
            return "937ecece725182fb27639df868a70d6c";
        }
        NodeInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            nodeName = "";
            nodeObj = "";
            endpointIp = "";
            endpointPort = 0;
            timeOut = 0;
            dataDir = "";
            version = "";
            coreFileSize = "";
            openFiles = 0;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(nodeName, 0);
            _os.write(nodeObj, 1);
            _os.write(endpointIp, 2);
            _os.write(endpointPort, 3);
            _os.write(timeOut, 4);
            _os.write(dataDir, 5);
            if (version != "")
            {
                _os.write(version, 6);
            }
            if (coreFileSize != "")
            {
                _os.write(coreFileSize, 7);
            }
            if (openFiles != 0)
            {
                _os.write(openFiles, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(nodeName, 0, true);
            _is.read(nodeObj, 1, true);
            _is.read(endpointIp, 2, true);
            _is.read(endpointPort, 3, true);
            _is.read(timeOut, 4, true);
            _is.read(dataDir, 5, true);
            _is.read(version, 6, false);
            _is.read(coreFileSize, 7, false);
            _is.read(openFiles, 8, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["nodeName"] = kant::JsonOutput::writeJson(nodeName);
            p->value["nodeObj"] = kant::JsonOutput::writeJson(nodeObj);
            p->value["endpointIp"] = kant::JsonOutput::writeJson(endpointIp);
            p->value["endpointPort"] = kant::JsonOutput::writeJson(endpointPort);
            p->value["timeOut"] = kant::JsonOutput::writeJson(timeOut);
            p->value["dataDir"] = kant::JsonOutput::writeJson(dataDir);
            p->value["version"] = kant::JsonOutput::writeJson(version);
            p->value["coreFileSize"] = kant::JsonOutput::writeJson(coreFileSize);
            p->value["openFiles"] = kant::JsonOutput::writeJson(openFiles);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(nodeName,pObj->value["nodeName"], true);
            kant::JsonInput::readJson(nodeObj,pObj->value["nodeObj"], true);
            kant::JsonInput::readJson(endpointIp,pObj->value["endpointIp"], true);
            kant::JsonInput::readJson(endpointPort,pObj->value["endpointPort"], true);
            kant::JsonInput::readJson(timeOut,pObj->value["timeOut"], true);
            kant::JsonInput::readJson(dataDir,pObj->value["dataDir"], true);
            kant::JsonInput::readJson(version,pObj->value["version"], false);
            kant::JsonInput::readJson(coreFileSize,pObj->value["coreFileSize"], false);
            kant::JsonInput::readJson(openFiles,pObj->value["openFiles"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(nodeName,"nodeName");
            _ds.display(nodeObj,"nodeObj");
            _ds.display(endpointIp,"endpointIp");
            _ds.display(endpointPort,"endpointPort");
            _ds.display(timeOut,"timeOut");
            _ds.display(dataDir,"dataDir");
            _ds.display(version,"version");
            _ds.display(coreFileSize,"coreFileSize");
            _ds.display(openFiles,"openFiles");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(nodeObj, true);
            _ds.displaySimple(endpointIp, true);
            _ds.displaySimple(endpointPort, true);
            _ds.displaySimple(timeOut, true);
            _ds.displaySimple(dataDir, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(coreFileSize, true);
            _ds.displaySimple(openFiles, false);
            return _os;
        }
    public:
        std::string nodeName;
        std::string nodeObj;
        std::string endpointIp;
        kant::Int32 endpointPort;
        kant::Short timeOut;
        std::string dataDir;
        std::string version;
        std::string coreFileSize;
        kant::Int32 openFiles;
    };
    inline bool operator==(const NodeInfo&l, const NodeInfo&r)
    {
        return l.nodeName == r.nodeName && l.nodeObj == r.nodeObj && l.endpointIp == r.endpointIp && l.endpointPort == r.endpointPort && l.timeOut == r.timeOut && l.dataDir == r.dataDir && l.version == r.version && l.coreFileSize == r.coreFileSize && l.openFiles == r.openFiles;
    }
    inline bool operator!=(const NodeInfo&l, const NodeInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const NodeInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,NodeInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ServerStateInfo : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.ServerStateInfo";
        }
        static string MD5()
        {
            return "0b19c035719bf063dd2d1e53b1ae0a78";
        }
        ServerStateInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            serverState = kant::Inactive;
            processId = 0;
            nodeName = "";
            application = "";
            serverName = "";
            settingState = kant::Inactive;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write((kant::Int32)serverState, 0);
            _os.write(processId, 1);
            if (nodeName != "")
            {
                _os.write(nodeName, 2);
            }
            if (application != "")
            {
                _os.write(application, 3);
            }
            if (serverName != "")
            {
                _os.write(serverName, 4);
            }
            _os.write((kant::Int32)settingState, 5);
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            kant::Int32 eTemp0 = kant::Inactive;
            _is.read(eTemp0, 0, true);
            serverState = (kant::ServerState)eTemp0;
            _is.read(processId, 1, true);
            _is.read(nodeName, 2, false);
            _is.read(application, 3, false);
            _is.read(serverName, 4, false);
            kant::Int32 eTemp5 = kant::Inactive;
            _is.read(eTemp5, 5, false);
            settingState = (kant::ServerState)eTemp5;
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["serverState"] = kant::JsonOutput::writeJson((kant::Int32)serverState);
            p->value["processId"] = kant::JsonOutput::writeJson(processId);
            p->value["nodeName"] = kant::JsonOutput::writeJson(nodeName);
            p->value["application"] = kant::JsonOutput::writeJson(application);
            p->value["serverName"] = kant::JsonOutput::writeJson(serverName);
            p->value["settingState"] = kant::JsonOutput::writeJson((kant::Int32)settingState);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(serverState,pObj->value["serverState"], true);
            kant::JsonInput::readJson(processId,pObj->value["processId"], true);
            kant::JsonInput::readJson(nodeName,pObj->value["nodeName"], false);
            kant::JsonInput::readJson(application,pObj->value["application"], false);
            kant::JsonInput::readJson(serverName,pObj->value["serverName"], false);
            kant::JsonInput::readJson(settingState,pObj->value["settingState"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display((kant::Int32)serverState,"serverState");
            _ds.display(processId,"processId");
            _ds.display(nodeName,"nodeName");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display((kant::Int32)settingState,"settingState");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple((kant::Int32)serverState, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple((kant::Int32)settingState, false);
            return _os;
        }
    public:
        kant::ServerState serverState;
        kant::Int32 processId;
        std::string nodeName;
        std::string application;
        std::string serverName;
        kant::ServerState settingState;
    };
    inline bool operator==(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return l.serverState == r.serverState && l.processId == r.processId && l.nodeName == r.nodeName && l.application == r.application && l.serverName == r.serverName && l.settingState == r.settingState;
    }
    inline bool operator!=(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerStateInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerStateInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PatchRequest : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.PatchRequest";
        }
        static string MD5()
        {
            return "b1b7c1f4565fe3a2a3749c726451a6f9";
        }
        PatchRequest()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            appname = "";
            servername = "";
            nodename = "";
            groupname = "";
            binname = "";
            version = "";
            user = "";
            servertype = "";
            patchobj = "";
            md5 = "";
            ostype = "";
            filepath = "";
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(appname, 0);
            _os.write(servername, 1);
            _os.write(nodename, 2);
            _os.write(groupname, 3);
            _os.write(binname, 4);
            _os.write(version, 5);
            _os.write(user, 6);
            _os.write(servertype, 7);
            _os.write(patchobj, 8);
            _os.write(md5, 9);
            if (ostype != "")
            {
                _os.write(ostype, 10);
            }
            if (filepath != "")
            {
                _os.write(filepath, 11);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appname, 0, true);
            _is.read(servername, 1, true);
            _is.read(nodename, 2, true);
            _is.read(groupname, 3, true);
            _is.read(binname, 4, true);
            _is.read(version, 5, true);
            _is.read(user, 6, true);
            _is.read(servertype, 7, true);
            _is.read(patchobj, 8, true);
            _is.read(md5, 9, true);
            _is.read(ostype, 10, false);
            _is.read(filepath, 11, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["appname"] = kant::JsonOutput::writeJson(appname);
            p->value["servername"] = kant::JsonOutput::writeJson(servername);
            p->value["nodename"] = kant::JsonOutput::writeJson(nodename);
            p->value["groupname"] = kant::JsonOutput::writeJson(groupname);
            p->value["binname"] = kant::JsonOutput::writeJson(binname);
            p->value["version"] = kant::JsonOutput::writeJson(version);
            p->value["user"] = kant::JsonOutput::writeJson(user);
            p->value["servertype"] = kant::JsonOutput::writeJson(servertype);
            p->value["patchobj"] = kant::JsonOutput::writeJson(patchobj);
            p->value["md5"] = kant::JsonOutput::writeJson(md5);
            p->value["ostype"] = kant::JsonOutput::writeJson(ostype);
            p->value["filepath"] = kant::JsonOutput::writeJson(filepath);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(appname,pObj->value["appname"], true);
            kant::JsonInput::readJson(servername,pObj->value["servername"], true);
            kant::JsonInput::readJson(nodename,pObj->value["nodename"], true);
            kant::JsonInput::readJson(groupname,pObj->value["groupname"], true);
            kant::JsonInput::readJson(binname,pObj->value["binname"], true);
            kant::JsonInput::readJson(version,pObj->value["version"], true);
            kant::JsonInput::readJson(user,pObj->value["user"], true);
            kant::JsonInput::readJson(servertype,pObj->value["servertype"], true);
            kant::JsonInput::readJson(patchobj,pObj->value["patchobj"], true);
            kant::JsonInput::readJson(md5,pObj->value["md5"], true);
            kant::JsonInput::readJson(ostype,pObj->value["ostype"], false);
            kant::JsonInput::readJson(filepath,pObj->value["filepath"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(appname,"appname");
            _ds.display(servername,"servername");
            _ds.display(nodename,"nodename");
            _ds.display(groupname,"groupname");
            _ds.display(binname,"binname");
            _ds.display(version,"version");
            _ds.display(user,"user");
            _ds.display(servertype,"servertype");
            _ds.display(patchobj,"patchobj");
            _ds.display(md5,"md5");
            _ds.display(ostype,"ostype");
            _ds.display(filepath,"filepath");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(appname, true);
            _ds.displaySimple(servername, true);
            _ds.displaySimple(nodename, true);
            _ds.displaySimple(groupname, true);
            _ds.displaySimple(binname, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(user, true);
            _ds.displaySimple(servertype, true);
            _ds.displaySimple(patchobj, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(ostype, true);
            _ds.displaySimple(filepath, false);
            return _os;
        }
    public:
        std::string appname;
        std::string servername;
        std::string nodename;
        std::string groupname;
        std::string binname;
        std::string version;
        std::string user;
        std::string servertype;
        std::string patchobj;
        std::string md5;
        std::string ostype;
        std::string filepath;
    };
    inline bool operator==(const PatchRequest&l, const PatchRequest&r)
    {
        return l.appname == r.appname && l.servername == r.servername && l.nodename == r.nodename && l.groupname == r.groupname && l.binname == r.binname && l.version == r.version && l.user == r.user && l.servertype == r.servertype && l.patchobj == r.patchobj && l.md5 == r.md5 && l.ostype == r.ostype && l.filepath == r.filepath;
    }
    inline bool operator!=(const PatchRequest&l, const PatchRequest&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PatchRequest&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PatchRequest&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
