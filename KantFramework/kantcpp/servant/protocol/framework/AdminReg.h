// **********************************************************************
// This file was generated by a KANT parser!
// KANT version KANT_VERSION.
// **********************************************************************

#ifndef __ADMINREG_H_
#define __ADMINREG_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Kant.h"
#include "tup/KantJson.h"
using namespace std;
#include "NodeDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace kant
{
    enum kantErrCode
    {
        EM_KANT_NODE_NOT_REGISTRY_ERR = 1001,
        EM_KANT_CALL_NODE_TIMEOUT_ERR = 1002,
        EM_KANT_LOAD_SERVICE_DESC_ERR = 1003,
        EM_KANT_SERVICE_STATE_ERR = 1004,
        EM_KANT_REQ_ALREADY_ERR = 1005,
        EM_KANT_INVALID_IP_ERR = 1006,
        EM_KANT_PARAMETER_ERR = 1007,
        EM_KANT_OTHER_ERR = 1008,
        EM_KANT_GET_PATCH_FILE_ERR = 1009,
        EM_KANT_PREPARE_ERR = 1010,
        EM_KANT_CAN_NOT_EXECUTE = 1011,
        EM_KANT_UNKNOWN_ERR = -1,
        EM_KANT_SUCCESS = 0,
    };
    inline string etos(const kantErrCode & e)
    {
        switch(e)
        {
            case EM_KANT_NODE_NOT_REGISTRY_ERR: return "EM_KANT_NODE_NOT_REGISTRY_ERR";
            case EM_KANT_CALL_NODE_TIMEOUT_ERR: return "EM_KANT_CALL_NODE_TIMEOUT_ERR";
            case EM_KANT_LOAD_SERVICE_DESC_ERR: return "EM_KANT_LOAD_SERVICE_DESC_ERR";
            case EM_KANT_SERVICE_STATE_ERR: return "EM_KANT_SERVICE_STATE_ERR";
            case EM_KANT_REQ_ALREADY_ERR: return "EM_KANT_REQ_ALREADY_ERR";
            case EM_KANT_INVALID_IP_ERR: return "EM_KANT_INVALID_IP_ERR";
            case EM_KANT_PARAMETER_ERR: return "EM_KANT_PARAMETER_ERR";
            case EM_KANT_OTHER_ERR: return "EM_KANT_OTHER_ERR";
            case EM_KANT_GET_PATCH_FILE_ERR: return "EM_KANT_GET_PATCH_FILE_ERR";
            case EM_KANT_PREPARE_ERR: return "EM_KANT_PREPARE_ERR";
            case EM_KANT_CAN_NOT_EXECUTE: return "EM_KANT_CAN_NOT_EXECUTE";
            case EM_KANT_UNKNOWN_ERR: return "EM_KANT_UNKNOWN_ERR";
            case EM_KANT_SUCCESS: return "EM_KANT_SUCCESS";
            default: return "";
        }
    }
    inline int stoe(const string & s, kantErrCode & e)
    {
        if(s == "EM_KANT_NODE_NOT_REGISTRY_ERR")  { e=EM_KANT_NODE_NOT_REGISTRY_ERR; return 0;}
        if(s == "EM_KANT_CALL_NODE_TIMEOUT_ERR")  { e=EM_KANT_CALL_NODE_TIMEOUT_ERR; return 0;}
        if(s == "EM_KANT_LOAD_SERVICE_DESC_ERR")  { e=EM_KANT_LOAD_SERVICE_DESC_ERR; return 0;}
        if(s == "EM_KANT_SERVICE_STATE_ERR")  { e=EM_KANT_SERVICE_STATE_ERR; return 0;}
        if(s == "EM_KANT_REQ_ALREADY_ERR")  { e=EM_KANT_REQ_ALREADY_ERR; return 0;}
        if(s == "EM_KANT_INVALID_IP_ERR")  { e=EM_KANT_INVALID_IP_ERR; return 0;}
        if(s == "EM_KANT_PARAMETER_ERR")  { e=EM_KANT_PARAMETER_ERR; return 0;}
        if(s == "EM_KANT_OTHER_ERR")  { e=EM_KANT_OTHER_ERR; return 0;}
        if(s == "EM_KANT_GET_PATCH_FILE_ERR")  { e=EM_KANT_GET_PATCH_FILE_ERR; return 0;}
        if(s == "EM_KANT_PREPARE_ERR")  { e=EM_KANT_PREPARE_ERR; return 0;}
        if(s == "EM_KANT_CAN_NOT_EXECUTE")  { e=EM_KANT_CAN_NOT_EXECUTE; return 0;}
        if(s == "EM_KANT_UNKNOWN_ERR")  { e=EM_KANT_UNKNOWN_ERR; return 0;}
        if(s == "EM_KANT_SUCCESS")  { e=EM_KANT_SUCCESS; return 0;}

        return -1;
    }

    enum EMTaskCommand
    {
        EM_CMD_START,
        EM_CMD_STOP,
        EM_CMD_PATCH,
        EM_CMD_UNINSTALL,
    };
    inline string etos(const EMTaskCommand & e)
    {
        switch(e)
        {
            case EM_CMD_START: return "EM_CMD_START";
            case EM_CMD_STOP: return "EM_CMD_STOP";
            case EM_CMD_PATCH: return "EM_CMD_PATCH";
            case EM_CMD_UNINSTALL: return "EM_CMD_UNINSTALL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskCommand & e)
    {
        if(s == "EM_CMD_START")  { e=EM_CMD_START; return 0;}
        if(s == "EM_CMD_STOP")  { e=EM_CMD_STOP; return 0;}
        if(s == "EM_CMD_PATCH")  { e=EM_CMD_PATCH; return 0;}
        if(s == "EM_CMD_UNINSTALL")  { e=EM_CMD_UNINSTALL; return 0;}

        return -1;
    }

    enum EMTaskStatus
    {
        EM_T_NOT_START,
        EM_T_PREPARE,
        EM_T_RUNNING,
        EM_T_SUCCESS,
        EM_T_FAILED,
        EM_T_CANCEL,
        EM_T_PARIAL,
    };
    inline string etos(const EMTaskStatus & e)
    {
        switch(e)
        {
            case EM_T_NOT_START: return "EM_T_NOT_START";
            case EM_T_PREPARE: return "EM_T_PREPARE";
            case EM_T_RUNNING: return "EM_T_RUNNING";
            case EM_T_SUCCESS: return "EM_T_SUCCESS";
            case EM_T_FAILED: return "EM_T_FAILED";
            case EM_T_CANCEL: return "EM_T_CANCEL";
            case EM_T_PARIAL: return "EM_T_PARIAL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskStatus & e)
    {
        if(s == "EM_T_NOT_START")  { e=EM_T_NOT_START; return 0;}
        if(s == "EM_T_PREPARE")  { e=EM_T_PREPARE; return 0;}
        if(s == "EM_T_RUNNING")  { e=EM_T_RUNNING; return 0;}
        if(s == "EM_T_SUCCESS")  { e=EM_T_SUCCESS; return 0;}
        if(s == "EM_T_FAILED")  { e=EM_T_FAILED; return 0;}
        if(s == "EM_T_CANCEL")  { e=EM_T_CANCEL; return 0;}
        if(s == "EM_T_PARIAL")  { e=EM_T_PARIAL; return 0;}

        return -1;
    }

    enum EMTaskItemStatus
    {
        EM_I_NOT_START,
        EM_I_PREPARE,
        EM_I_RUNNING,
        EM_I_SUCCESS,
        EM_I_FAILED,
        EM_I_CANCEL,
        EM_I_PAUSE_FLOW,
    };
    inline string etos(const EMTaskItemStatus & e)
    {
        switch(e)
        {
            case EM_I_NOT_START: return "EM_I_NOT_START";
            case EM_I_PREPARE: return "EM_I_PREPARE";
            case EM_I_RUNNING: return "EM_I_RUNNING";
            case EM_I_SUCCESS: return "EM_I_SUCCESS";
            case EM_I_FAILED: return "EM_I_FAILED";
            case EM_I_CANCEL: return "EM_I_CANCEL";
            case EM_I_PAUSE_FLOW: return "EM_I_PAUSE_FLOW";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskItemStatus & e)
    {
        if(s == "EM_I_NOT_START")  { e=EM_I_NOT_START; return 0;}
        if(s == "EM_I_PREPARE")  { e=EM_I_PREPARE; return 0;}
        if(s == "EM_I_RUNNING")  { e=EM_I_RUNNING; return 0;}
        if(s == "EM_I_SUCCESS")  { e=EM_I_SUCCESS; return 0;}
        if(s == "EM_I_FAILED")  { e=EM_I_FAILED; return 0;}
        if(s == "EM_I_CANCEL")  { e=EM_I_CANCEL; return 0;}
        if(s == "EM_I_PAUSE_FLOW")  { e=EM_I_PAUSE_FLOW; return 0;}

        return -1;
    }

    struct ServerStateDesc : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.ServerStateDesc";
        }
        static string MD5()
        {
            return "09780eb7b6d87617bff374db3a24305c";
        }
        ServerStateDesc()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            settingStateInReg = "";
            presentStateInReg = "";
            presentStateInNode = "";
            processId = 0;
            patchVersion = "";
            patchTime = "";
            patchUser = "";
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(settingStateInReg, 0);
            _os.write(presentStateInReg, 1);
            _os.write(presentStateInNode, 2);
            _os.write(processId, 3);
            _os.write(patchVersion, 4);
            _os.write(patchTime, 5);
            _os.write(patchUser, 6);
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(settingStateInReg, 0, true);
            _is.read(presentStateInReg, 1, true);
            _is.read(presentStateInNode, 2, true);
            _is.read(processId, 3, true);
            _is.read(patchVersion, 4, true);
            _is.read(patchTime, 5, true);
            _is.read(patchUser, 6, true);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["settingStateInReg"] = kant::JsonOutput::writeJson(settingStateInReg);
            p->value["presentStateInReg"] = kant::JsonOutput::writeJson(presentStateInReg);
            p->value["presentStateInNode"] = kant::JsonOutput::writeJson(presentStateInNode);
            p->value["processId"] = kant::JsonOutput::writeJson(processId);
            p->value["patchVersion"] = kant::JsonOutput::writeJson(patchVersion);
            p->value["patchTime"] = kant::JsonOutput::writeJson(patchTime);
            p->value["patchUser"] = kant::JsonOutput::writeJson(patchUser);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(settingStateInReg,pObj->value["settingStateInReg"], true);
            kant::JsonInput::readJson(presentStateInReg,pObj->value["presentStateInReg"], true);
            kant::JsonInput::readJson(presentStateInNode,pObj->value["presentStateInNode"], true);
            kant::JsonInput::readJson(processId,pObj->value["processId"], true);
            kant::JsonInput::readJson(patchVersion,pObj->value["patchVersion"], true);
            kant::JsonInput::readJson(patchTime,pObj->value["patchTime"], true);
            kant::JsonInput::readJson(patchUser,pObj->value["patchUser"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(settingStateInReg,"settingStateInReg");
            _ds.display(presentStateInReg,"presentStateInReg");
            _ds.display(presentStateInNode,"presentStateInNode");
            _ds.display(processId,"processId");
            _ds.display(patchVersion,"patchVersion");
            _ds.display(patchTime,"patchTime");
            _ds.display(patchUser,"patchUser");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(settingStateInReg, true);
            _ds.displaySimple(presentStateInReg, true);
            _ds.displaySimple(presentStateInNode, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(patchVersion, true);
            _ds.displaySimple(patchTime, true);
            _ds.displaySimple(patchUser, false);
            return _os;
        }
    public:
        std::string settingStateInReg;
        std::string presentStateInReg;
        std::string presentStateInNode;
        kant::Int32 processId;
        std::string patchVersion;
        std::string patchTime;
        std::string patchUser;
    };
    inline bool operator==(const ServerStateDesc&l, const ServerStateDesc&r)
    {
        return l.settingStateInReg == r.settingStateInReg && l.presentStateInReg == r.presentStateInReg && l.presentStateInNode == r.presentStateInNode && l.processId == r.processId && l.patchVersion == r.patchVersion && l.patchTime == r.patchTime && l.patchUser == r.patchUser;
    }
    inline bool operator!=(const ServerStateDesc&l, const ServerStateDesc&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerStateDesc&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerStateDesc&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskItemReq : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.TaskItemReq";
        }
        static string MD5()
        {
            return "81985ab5572d614277b48adc89fb3c33";
        }
        TaskItemReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            taskNo = "";
            itemNo = "";
            application = "";
            serverName = "";
            nodeName = "";
            setName = "";
            command = "";
            userName = "";
            parameters.clear();
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            if (taskNo != "")
            {
                _os.write(taskNo, 0);
            }
            if (itemNo != "")
            {
                _os.write(itemNo, 1);
            }
            if (application != "")
            {
                _os.write(application, 2);
            }
            if (serverName != "")
            {
                _os.write(serverName, 3);
            }
            if (nodeName != "")
            {
                _os.write(nodeName, 4);
            }
            if (setName != "")
            {
                _os.write(setName, 5);
            }
            if (command != "")
            {
                _os.write(command, 6);
            }
            if (userName != "")
            {
                _os.write(userName, 7);
            }
            if (parameters.size() > 0)
            {
                _os.write(parameters, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskNo, 0, false);
            _is.read(itemNo, 1, false);
            _is.read(application, 2, false);
            _is.read(serverName, 3, false);
            _is.read(nodeName, 4, false);
            _is.read(setName, 5, false);
            _is.read(command, 6, false);
            _is.read(userName, 7, false);
            _is.read(parameters, 8, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["taskNo"] = kant::JsonOutput::writeJson(taskNo);
            p->value["itemNo"] = kant::JsonOutput::writeJson(itemNo);
            p->value["application"] = kant::JsonOutput::writeJson(application);
            p->value["serverName"] = kant::JsonOutput::writeJson(serverName);
            p->value["nodeName"] = kant::JsonOutput::writeJson(nodeName);
            p->value["setName"] = kant::JsonOutput::writeJson(setName);
            p->value["command"] = kant::JsonOutput::writeJson(command);
            p->value["userName"] = kant::JsonOutput::writeJson(userName);
            p->value["parameters"] = kant::JsonOutput::writeJson(parameters);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(taskNo,pObj->value["taskNo"], false);
            kant::JsonInput::readJson(itemNo,pObj->value["itemNo"], false);
            kant::JsonInput::readJson(application,pObj->value["application"], false);
            kant::JsonInput::readJson(serverName,pObj->value["serverName"], false);
            kant::JsonInput::readJson(nodeName,pObj->value["nodeName"], false);
            kant::JsonInput::readJson(setName,pObj->value["setName"], false);
            kant::JsonInput::readJson(command,pObj->value["command"], false);
            kant::JsonInput::readJson(userName,pObj->value["userName"], false);
            kant::JsonInput::readJson(parameters,pObj->value["parameters"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(taskNo,"taskNo");
            _ds.display(itemNo,"itemNo");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(setName,"setName");
            _ds.display(command,"command");
            _ds.display(userName,"userName");
            _ds.display(parameters,"parameters");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(itemNo, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(setName, true);
            _ds.displaySimple(command, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(parameters, false);
            return _os;
        }
    public:
        std::string taskNo;
        std::string itemNo;
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string setName;
        std::string command;
        std::string userName;
        map<std::string, std::string> parameters;
    };
    inline bool operator==(const TaskItemReq&l, const TaskItemReq&r)
    {
        return l.taskNo == r.taskNo && l.itemNo == r.itemNo && l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.setName == r.setName && l.command == r.command && l.userName == r.userName && l.parameters == r.parameters;
    }
    inline bool operator!=(const TaskItemReq&l, const TaskItemReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskItemReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskItemReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskItemRsp : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.TaskItemRsp";
        }
        static string MD5()
        {
            return "f40a922885a6d21b68f3996ae09a8b70";
        }
        TaskItemRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            req.resetDefautlt();
            startTime = "";
            endTime = "";
            status = kant::EM_I_NOT_START;
            statusInfo = "";
            executeLog = "";
            percent = 0;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(req, 0);
            if (startTime != "")
            {
                _os.write(startTime, 1);
            }
            if (endTime != "")
            {
                _os.write(endTime, 2);
            }
            _os.write((kant::Int32)status, 3);
            if (statusInfo != "")
            {
                _os.write(statusInfo, 4);
            }
            if (executeLog != "")
            {
                _os.write(executeLog, 5);
            }
            if (percent != 0)
            {
                _os.write(percent, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(req, 0, false);
            _is.read(startTime, 1, false);
            _is.read(endTime, 2, false);
            kant::Int32 eTemp3 = kant::EM_I_NOT_START;
            _is.read(eTemp3, 3, false);
            status = (kant::EMTaskItemStatus)eTemp3;
            _is.read(statusInfo, 4, false);
            _is.read(executeLog, 5, false);
            _is.read(percent, 6, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["req"] = kant::JsonOutput::writeJson(req);
            p->value["startTime"] = kant::JsonOutput::writeJson(startTime);
            p->value["endTime"] = kant::JsonOutput::writeJson(endTime);
            p->value["status"] = kant::JsonOutput::writeJson((kant::Int32)status);
            p->value["statusInfo"] = kant::JsonOutput::writeJson(statusInfo);
            p->value["executeLog"] = kant::JsonOutput::writeJson(executeLog);
            p->value["percent"] = kant::JsonOutput::writeJson(percent);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(req,pObj->value["req"], false);
            kant::JsonInput::readJson(startTime,pObj->value["startTime"], false);
            kant::JsonInput::readJson(endTime,pObj->value["endTime"], false);
            kant::JsonInput::readJson(status,pObj->value["status"], false);
            kant::JsonInput::readJson(statusInfo,pObj->value["statusInfo"], false);
            kant::JsonInput::readJson(executeLog,pObj->value["executeLog"], false);
            kant::JsonInput::readJson(percent,pObj->value["percent"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(req,"req");
            _ds.display(startTime,"startTime");
            _ds.display(endTime,"endTime");
            _ds.display((kant::Int32)status,"status");
            _ds.display(statusInfo,"statusInfo");
            _ds.display(executeLog,"executeLog");
            _ds.display(percent,"percent");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(req, true);
            _ds.displaySimple(startTime, true);
            _ds.displaySimple(endTime, true);
            _ds.displaySimple((kant::Int32)status, true);
            _ds.displaySimple(statusInfo, true);
            _ds.displaySimple(executeLog, true);
            _ds.displaySimple(percent, false);
            return _os;
        }
    public:
        kant::TaskItemReq req;
        std::string startTime;
        std::string endTime;
        kant::EMTaskItemStatus status;
        std::string statusInfo;
        std::string executeLog;
        kant::Int32 percent;
    };
    inline bool operator==(const TaskItemRsp&l, const TaskItemRsp&r)
    {
        return l.req == r.req && l.startTime == r.startTime && l.endTime == r.endTime && l.status == r.status && l.statusInfo == r.statusInfo && l.executeLog == r.executeLog && l.percent == r.percent;
    }
    inline bool operator!=(const TaskItemRsp&l, const TaskItemRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskItemRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskItemRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskReq : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.TaskReq";
        }
        static string MD5()
        {
            return "ab90103f6b533756d7dccd8fa4f7ba6f";
        }
        TaskReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            taskItemReq.clear();
            taskNo = "";
            serial = true;
            userName = "";
            isElegant = false;
            eachNum = 1;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            if (taskItemReq.size() > 0)
            {
                _os.write(taskItemReq, 0);
            }
            if (taskNo != "")
            {
                _os.write(taskNo, 1);
            }
            if (serial != true)
            {
                _os.write(serial, 2);
            }
            if (userName != "")
            {
                _os.write(userName, 3);
            }
            if (isElegant != false)
            {
                _os.write(isElegant, 4);
            }
            if (eachNum != 1)
            {
                _os.write(eachNum, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskItemReq, 0, false);
            _is.read(taskNo, 1, false);
            _is.read(serial, 2, false);
            _is.read(userName, 3, false);
            _is.read(isElegant, 4, false);
            _is.read(eachNum, 5, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["taskItemReq"] = kant::JsonOutput::writeJson(taskItemReq);
            p->value["taskNo"] = kant::JsonOutput::writeJson(taskNo);
            p->value["serial"] = kant::JsonOutput::writeJson(serial);
            p->value["userName"] = kant::JsonOutput::writeJson(userName);
            p->value["isElegant"] = kant::JsonOutput::writeJson(isElegant);
            p->value["eachNum"] = kant::JsonOutput::writeJson(eachNum);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(taskItemReq,pObj->value["taskItemReq"], false);
            kant::JsonInput::readJson(taskNo,pObj->value["taskNo"], false);
            kant::JsonInput::readJson(serial,pObj->value["serial"], false);
            kant::JsonInput::readJson(userName,pObj->value["userName"], false);
            kant::JsonInput::readJson(isElegant,pObj->value["isElegant"], false);
            kant::JsonInput::readJson(eachNum,pObj->value["eachNum"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(taskItemReq,"taskItemReq");
            _ds.display(taskNo,"taskNo");
            _ds.display(serial,"serial");
            _ds.display(userName,"userName");
            _ds.display(isElegant,"isElegant");
            _ds.display(eachNum,"eachNum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(taskItemReq, true);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(serial, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(isElegant, true);
            _ds.displaySimple(eachNum, false);
            return _os;
        }
    public:
        vector<kant::TaskItemReq> taskItemReq;
        std::string taskNo;
        kant::Bool serial;
        std::string userName;
        kant::Bool isElegant;
        kant::Int32 eachNum;
    };
    inline bool operator==(const TaskReq&l, const TaskReq&r)
    {
        return l.taskItemReq == r.taskItemReq && l.taskNo == r.taskNo && l.serial == r.serial && l.userName == r.userName && l.isElegant == r.isElegant && l.eachNum == r.eachNum;
    }
    inline bool operator!=(const TaskReq&l, const TaskReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskRsp : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.TaskRsp";
        }
        static string MD5()
        {
            return "ced6895ec58885ceac3c0f5aad401701";
        }
        TaskRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            taskItemRsp.clear();
            taskNo = "";
            serial = true;
            userName = "";
            status = kant::EM_T_NOT_START;
            createTime = "";
            executeLog = "";
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            if (taskItemRsp.size() > 0)
            {
                _os.write(taskItemRsp, 0);
            }
            if (taskNo != "")
            {
                _os.write(taskNo, 1);
            }
            if (serial != true)
            {
                _os.write(serial, 2);
            }
            if (userName != "")
            {
                _os.write(userName, 3);
            }
            _os.write((kant::Int32)status, 4);
            if (createTime != "")
            {
                _os.write(createTime, 5);
            }
            if (executeLog != "")
            {
                _os.write(executeLog, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskItemRsp, 0, false);
            _is.read(taskNo, 1, false);
            _is.read(serial, 2, false);
            _is.read(userName, 3, false);
            kant::Int32 eTemp4 = kant::EM_T_NOT_START;
            _is.read(eTemp4, 4, false);
            status = (kant::EMTaskStatus)eTemp4;
            _is.read(createTime, 5, false);
            _is.read(executeLog, 6, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["taskItemRsp"] = kant::JsonOutput::writeJson(taskItemRsp);
            p->value["taskNo"] = kant::JsonOutput::writeJson(taskNo);
            p->value["serial"] = kant::JsonOutput::writeJson(serial);
            p->value["userName"] = kant::JsonOutput::writeJson(userName);
            p->value["status"] = kant::JsonOutput::writeJson((kant::Int32)status);
            p->value["createTime"] = kant::JsonOutput::writeJson(createTime);
            p->value["executeLog"] = kant::JsonOutput::writeJson(executeLog);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(taskItemRsp,pObj->value["taskItemRsp"], false);
            kant::JsonInput::readJson(taskNo,pObj->value["taskNo"], false);
            kant::JsonInput::readJson(serial,pObj->value["serial"], false);
            kant::JsonInput::readJson(userName,pObj->value["userName"], false);
            kant::JsonInput::readJson(status,pObj->value["status"], false);
            kant::JsonInput::readJson(createTime,pObj->value["createTime"], false);
            kant::JsonInput::readJson(executeLog,pObj->value["executeLog"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(taskItemRsp,"taskItemRsp");
            _ds.display(taskNo,"taskNo");
            _ds.display(serial,"serial");
            _ds.display(userName,"userName");
            _ds.display((kant::Int32)status,"status");
            _ds.display(createTime,"createTime");
            _ds.display(executeLog,"executeLog");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(taskItemRsp, true);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(serial, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple((kant::Int32)status, true);
            _ds.displaySimple(createTime, true);
            _ds.displaySimple(executeLog, false);
            return _os;
        }
    public:
        vector<kant::TaskItemRsp> taskItemRsp;
        std::string taskNo;
        kant::Bool serial;
        std::string userName;
        kant::EMTaskStatus status;
        std::string createTime;
        std::string executeLog;
    };
    inline bool operator==(const TaskRsp&l, const TaskRsp&r)
    {
        return l.taskItemRsp == r.taskItemRsp && l.taskNo == r.taskNo && l.serial == r.serial && l.userName == r.userName && l.status == r.status && l.createTime == r.createTime && l.executeLog == r.executeLog;
    }
    inline bool operator!=(const TaskRsp&l, const TaskRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FrameworkServer : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.FrameworkServer";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        FrameworkServer()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            serverName = "";
            nodeName = "";
            objName = "";
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(serverName, 0);
            _os.write(nodeName, 1);
            _os.write(objName, 2);
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(serverName, 0, true);
            _is.read(nodeName, 1, true);
            _is.read(objName, 2, true);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["serverName"] = kant::JsonOutput::writeJson(serverName);
            p->value["nodeName"] = kant::JsonOutput::writeJson(nodeName);
            p->value["objName"] = kant::JsonOutput::writeJson(objName);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(serverName,pObj->value["serverName"], true);
            kant::JsonInput::readJson(nodeName,pObj->value["nodeName"], true);
            kant::JsonInput::readJson(objName,pObj->value["objName"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(objName,"objName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(objName, false);
            return _os;
        }
    public:
        std::string serverName;
        std::string nodeName;
        std::string objName;
    };
    inline bool operator==(const FrameworkServer&l, const FrameworkServer&r)
    {
        return l.serverName == r.serverName && l.nodeName == r.nodeName && l.objName == r.objName;
    }
    inline bool operator!=(const FrameworkServer&l, const FrameworkServer&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FrameworkServer&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FrameworkServer&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


    /* callback of async proxy for client */
    class AdminRegPrxCallback: public kant::ServantProxyCallback
    {
    public:
        virtual ~AdminRegPrxCallback(){}
        virtual void callback_addTaskReq(kant::Int32 ret)
        { throw std::runtime_error("callback_addTaskReq() override incorrect."); }
        virtual void callback_addTaskReq_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_addTaskReq_exception() override incorrect."); }

        virtual void callback_batchPatch(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_batchPatch() override incorrect."); }
        virtual void callback_batchPatch_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_batchPatch_exception() override incorrect."); }

        virtual void callback_checkDockerRegistry(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_checkDockerRegistry() override incorrect."); }
        virtual void callback_checkDockerRegistry_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_checkDockerRegistry_exception() override incorrect."); }

        virtual void callback_checkServer(kant::Int32 ret)
        { throw std::runtime_error("callback_checkServer() override incorrect."); }
        virtual void callback_checkServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_checkServer_exception() override incorrect."); }

        virtual void callback_deletePatchFile(kant::Int32 ret)
        { throw std::runtime_error("callback_deletePatchFile() override incorrect."); }
        virtual void callback_deletePatchFile_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_deletePatchFile_exception() override incorrect."); }

        virtual void callback_dockerPull(kant::Int32 ret)
        { throw std::runtime_error("callback_dockerPull() override incorrect."); }
        virtual void callback_dockerPull_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_dockerPull_exception() override incorrect."); }

        virtual void callback_forceDockerLogin(kant::Int32 ret,  const vector<std::string>& result)
        { throw std::runtime_error("callback_forceDockerLogin() override incorrect."); }
        virtual void callback_forceDockerLogin_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_forceDockerLogin_exception() override incorrect."); }

        virtual void callback_getAllApplicationNames(const vector<std::string>& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllApplicationNames() override incorrect."); }
        virtual void callback_getAllApplicationNames_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getAllApplicationNames_exception() override incorrect."); }

        virtual void callback_getAllNodeNames(const vector<std::string>& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllNodeNames() override incorrect."); }
        virtual void callback_getAllNodeNames_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getAllNodeNames_exception() override incorrect."); }

        virtual void callback_getAllServerIds(const vector<vector<std::string> >& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllServerIds() override incorrect."); }
        virtual void callback_getAllServerIds_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getAllServerIds_exception() override incorrect."); }

        virtual void callback_getClientIp(kant::Int32 ret,  const std::string& sClientIp)
        { throw std::runtime_error("callback_getClientIp() override incorrect."); }
        virtual void callback_getClientIp_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getClientIp_exception() override incorrect."); }

        virtual void callback_getGroupId(kant::Int32 ret, kant::Int32 groupId,  const std::string& result)
        { throw std::runtime_error("callback_getGroupId() override incorrect."); }
        virtual void callback_getGroupId_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getGroupId_exception() override incorrect."); }

        virtual void callback_getLogData(kant::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getLogData() override incorrect."); }
        virtual void callback_getLogData_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getLogData_exception() override incorrect."); }

        virtual void callback_getLogFileList(kant::Int32 ret,  const vector<std::string>& logFileList)
        { throw std::runtime_error("callback_getLogFileList() override incorrect."); }
        virtual void callback_getLogFileList_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getLogFileList_exception() override incorrect."); }

        virtual void callback_getNodeLoad(kant::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getNodeLoad() override incorrect."); }
        virtual void callback_getNodeLoad_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getNodeLoad_exception() override incorrect."); }

        virtual void callback_getNodeVesion(kant::Int32 ret,  const std::string& version,  const std::string& result)
        { throw std::runtime_error("callback_getNodeVesion() override incorrect."); }
        virtual void callback_getNodeVesion_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getNodeVesion_exception() override incorrect."); }

        virtual void callback_getPatchPercent(kant::Int32 ret,  const kant::PatchInfo& tPatchInfo)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }

        virtual void callback_getProfileTemplate(kant::Int32 ret,  const std::string& profileTemplate,  const std::string& resultDesc)
        { throw std::runtime_error("callback_getProfileTemplate() override incorrect."); }
        virtual void callback_getProfileTemplate_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getProfileTemplate_exception() override incorrect."); }

        virtual void callback_getServerProfileTemplate(kant::Int32 ret,  const std::string& profileTemplate,  const std::string& resultDesc)
        { throw std::runtime_error("callback_getServerProfileTemplate() override incorrect."); }
        virtual void callback_getServerProfileTemplate_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getServerProfileTemplate_exception() override incorrect."); }

        virtual void callback_getServerState(kant::Int32 ret,  const kant::ServerStateDesc& state,  const std::string& result)
        { throw std::runtime_error("callback_getServerState() override incorrect."); }
        virtual void callback_getServerState_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getServerState_exception() override incorrect."); }

        virtual void callback_getServers(kant::Int32 ret,  const vector<kant::FrameworkServer>& servers)
        { throw std::runtime_error("callback_getServers() override incorrect."); }
        virtual void callback_getServers_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getServers_exception() override incorrect."); }

        virtual void callback_getTaskHistory(kant::Int32 ret,  const vector<kant::TaskRsp>& taskRsps)
        { throw std::runtime_error("callback_getTaskHistory() override incorrect."); }
        virtual void callback_getTaskHistory_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getTaskHistory_exception() override incorrect."); }

        virtual void callback_getTaskRsp(kant::Int32 ret,  const kant::TaskRsp& taskRsp)
        { throw std::runtime_error("callback_getTaskRsp() override incorrect."); }
        virtual void callback_getTaskRsp_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getTaskRsp_exception() override incorrect."); }

        virtual void callback_getVersion(kant::Int32 ret,  const std::string& version)
        { throw std::runtime_error("callback_getVersion() override incorrect."); }
        virtual void callback_getVersion_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getVersion_exception() override incorrect."); }

        virtual void callback_loadServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }

        virtual void callback_notifyServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }

        virtual void callback_pingNode(kant::Bool ret,  const std::string& result)
        { throw std::runtime_error("callback_pingNode() override incorrect."); }
        virtual void callback_pingNode_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_pingNode_exception() override incorrect."); }

        virtual void callback_restartServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_restartServer() override incorrect."); }
        virtual void callback_restartServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_restartServer_exception() override incorrect."); }

        virtual void callback_setTaskItemInfo(kant::Int32 ret)
        { throw std::runtime_error("callback_setTaskItemInfo() override incorrect."); }
        virtual void callback_setTaskItemInfo_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_setTaskItemInfo_exception() override incorrect."); }

        virtual void callback_shutdownNode(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_shutdownNode() override incorrect."); }
        virtual void callback_shutdownNode_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_shutdownNode_exception() override incorrect."); }

        virtual void callback_startServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }

        virtual void callback_stopServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }

        virtual void callback_undeploy(kant::Int32 ret,  const std::string& log)
        { throw std::runtime_error("callback_undeploy() override incorrect."); }
        virtual void callback_undeploy_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_undeploy_exception() override incorrect."); }

        virtual void callback_updatePatchLog(kant::Int32 ret)
        { throw std::runtime_error("callback_updatePatchLog() override incorrect."); }
        virtual void callback_updatePatchLog_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_updatePatchLog_exception() override incorrect."); }

        virtual void callback_updateServerFlowState(kant::Int32 ret)
        { throw std::runtime_error("callback_updateServerFlowState() override incorrect."); }
        virtual void callback_updateServerFlowState_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_updateServerFlowState_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw KT_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(kant::ReqMessagePtr msg)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "deletePatchFile",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog",
                "updateServerFlowState"
            };
            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+35, string(msg->request.sFuncName));
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_addTaskReq(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_batchPatch(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_checkDockerRegistry_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_checkDockerRegistry(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_checkServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_checkServer(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_deletePatchFile_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_deletePatchFile(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_dockerPull_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_dockerPull(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_forceDockerLogin(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    vector<std::string> _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getAllApplicationNames(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    vector<std::string> _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getAllNodeNames(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    vector<vector<std::string> > _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getAllServerIds(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string sClientIp;
                    _is.read(sClientIp, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getClientIp(_ret, sClientIp);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    kant::Int32 groupId;
                    _is.read(groupId, 2, true);
                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getGroupId(_ret, groupId, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogData_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 6, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getLogData(_ret, fileData);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> logFileList;
                    _is.read(logFileList, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getLogFileList(_ret, logFileList);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getNodeLoad(_ret, fileData);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string version;
                    _is.read(version, 2, true);
                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getNodeVesion(_ret, version, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    kant::PatchInfo tPatchInfo;
                    _is.read(tPatchInfo, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getPatchPercent(_ret, tPatchInfo);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string profileTemplate;
                    _is.read(profileTemplate, 2, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getProfileTemplate(_ret, profileTemplate, resultDesc);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string profileTemplate;
                    _is.read(profileTemplate, 4, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getServerProfileTemplate(_ret, profileTemplate, resultDesc);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    kant::ServerStateDesc state;
                    _is.read(state, 4, true);
                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getServerState(_ret, state, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServers_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<kant::FrameworkServer> servers;
                    _is.read(servers, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getServers(_ret, servers);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<kant::TaskRsp> taskRsps;
                    _is.read(taskRsps, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getTaskHistory(_ret, taskRsps);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    kant::TaskRsp taskRsp;
                    _is.read(taskRsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getTaskRsp(_ret, taskRsp);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 23:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getVersion_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string version;
                    _is.read(version, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getVersion(_ret, version);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 24:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_loadServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 25:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_notifyServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 26:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_pingNode_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_pingNode(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 27:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_restartServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_restartServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 28:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_setTaskItemInfo(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 29:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_shutdownNode(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 30:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_startServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 31:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_stopServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 32:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_undeploy_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string log;
                    _is.read(log, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_undeploy(_ret, log);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 33:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_updatePatchLog(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 34:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_updateServerFlowState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_updateServerFlowState(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }

    };
    typedef std::shared_ptr<AdminRegPrxCallback> AdminRegPrxCallbackPtr;

    //callback of promise async proxy for client
    class AdminRegPrxCallbackPromise: public kant::ServantProxyCallback
    {
    public:
        virtual ~AdminRegPrxCallbackPromise(){}
    public:
        struct PromiseaddTaskReq
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiseaddTaskReq > PromiseaddTaskReqPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > &promise)
        : _promise_addTaskReq(promise)
        {}
        
        virtual void callback_addTaskReq(const AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr &ptr)
        {
            _promise_addTaskReq.setValue(ptr);
        }
        virtual void callback_addTaskReq_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:addTaskReq_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_addTaskReq.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > _promise_addTaskReq;

    public:
        struct PromisebatchPatch
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisebatchPatch > PromisebatchPatchPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > &promise)
        : _promise_batchPatch(promise)
        {}
        
        virtual void callback_batchPatch(const AdminRegPrxCallbackPromise::PromisebatchPatchPtr &ptr)
        {
            _promise_batchPatch.setValue(ptr);
        }
        virtual void callback_batchPatch_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:batchPatch_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_batchPatch.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > _promise_batchPatch;

    public:
        struct PromisecheckDockerRegistry
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisecheckDockerRegistry > PromisecheckDockerRegistryPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > &promise)
        : _promise_checkDockerRegistry(promise)
        {}
        
        virtual void callback_checkDockerRegistry(const AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr &ptr)
        {
            _promise_checkDockerRegistry.setValue(ptr);
        }
        virtual void callback_checkDockerRegistry_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:checkDockerRegistry_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_checkDockerRegistry.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > _promise_checkDockerRegistry;

    public:
        struct PromisecheckServer
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisecheckServer > PromisecheckServerPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisecheckServerPtr > &promise)
        : _promise_checkServer(promise)
        {}
        
        virtual void callback_checkServer(const AdminRegPrxCallbackPromise::PromisecheckServerPtr &ptr)
        {
            _promise_checkServer.setValue(ptr);
        }
        virtual void callback_checkServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:checkServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_checkServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisecheckServerPtr > _promise_checkServer;

    public:
        struct PromisedeletePatchFile
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisedeletePatchFile > PromisedeletePatchFilePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > &promise)
        : _promise_deletePatchFile(promise)
        {}
        
        virtual void callback_deletePatchFile(const AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr &ptr)
        {
            _promise_deletePatchFile.setValue(ptr);
        }
        virtual void callback_deletePatchFile_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:deletePatchFile_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_deletePatchFile.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > _promise_deletePatchFile;

    public:
        struct PromisedockerPull
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisedockerPull > PromisedockerPullPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisedockerPullPtr > &promise)
        : _promise_dockerPull(promise)
        {}
        
        virtual void callback_dockerPull(const AdminRegPrxCallbackPromise::PromisedockerPullPtr &ptr)
        {
            _promise_dockerPull.setValue(ptr);
        }
        virtual void callback_dockerPull_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:dockerPull_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_dockerPull.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisedockerPullPtr > _promise_dockerPull;

    public:
        struct PromiseforceDockerLogin
        {
        public:
            kant::Int32 _ret;
            vector<std::string> result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiseforceDockerLogin > PromiseforceDockerLoginPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > &promise)
        : _promise_forceDockerLogin(promise)
        {}
        
        virtual void callback_forceDockerLogin(const AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr &ptr)
        {
            _promise_forceDockerLogin.setValue(ptr);
        }
        virtual void callback_forceDockerLogin_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:forceDockerLogin_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_forceDockerLogin.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > _promise_forceDockerLogin;

    public:
        struct PromisegetAllApplicationNames
        {
        public:
            vector<std::string> _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetAllApplicationNames > PromisegetAllApplicationNamesPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > &promise)
        : _promise_getAllApplicationNames(promise)
        {}
        
        virtual void callback_getAllApplicationNames(const AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr &ptr)
        {
            _promise_getAllApplicationNames.setValue(ptr);
        }
        virtual void callback_getAllApplicationNames_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllApplicationNames_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getAllApplicationNames.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > _promise_getAllApplicationNames;

    public:
        struct PromisegetAllNodeNames
        {
        public:
            vector<std::string> _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetAllNodeNames > PromisegetAllNodeNamesPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > &promise)
        : _promise_getAllNodeNames(promise)
        {}
        
        virtual void callback_getAllNodeNames(const AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr &ptr)
        {
            _promise_getAllNodeNames.setValue(ptr);
        }
        virtual void callback_getAllNodeNames_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllNodeNames_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getAllNodeNames.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > _promise_getAllNodeNames;

    public:
        struct PromisegetAllServerIds
        {
        public:
            vector<vector<std::string> > _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetAllServerIds > PromisegetAllServerIdsPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > &promise)
        : _promise_getAllServerIds(promise)
        {}
        
        virtual void callback_getAllServerIds(const AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr &ptr)
        {
            _promise_getAllServerIds.setValue(ptr);
        }
        virtual void callback_getAllServerIds_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllServerIds_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getAllServerIds.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > _promise_getAllServerIds;

    public:
        struct PromisegetClientIp
        {
        public:
            kant::Int32 _ret;
            std::string sClientIp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetClientIp > PromisegetClientIpPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > &promise)
        : _promise_getClientIp(promise)
        {}
        
        virtual void callback_getClientIp(const AdminRegPrxCallbackPromise::PromisegetClientIpPtr &ptr)
        {
            _promise_getClientIp.setValue(ptr);
        }
        virtual void callback_getClientIp_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getClientIp_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getClientIp.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > _promise_getClientIp;

    public:
        struct PromisegetGroupId
        {
        public:
            kant::Int32 _ret;
            kant::Int32 groupId;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetGroupId > PromisegetGroupIdPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > &promise)
        : _promise_getGroupId(promise)
        {}
        
        virtual void callback_getGroupId(const AdminRegPrxCallbackPromise::PromisegetGroupIdPtr &ptr)
        {
            _promise_getGroupId.setValue(ptr);
        }
        virtual void callback_getGroupId_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getGroupId_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getGroupId.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > _promise_getGroupId;

    public:
        struct PromisegetLogData
        {
        public:
            kant::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetLogData > PromisegetLogDataPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > &promise)
        : _promise_getLogData(promise)
        {}
        
        virtual void callback_getLogData(const AdminRegPrxCallbackPromise::PromisegetLogDataPtr &ptr)
        {
            _promise_getLogData.setValue(ptr);
        }
        virtual void callback_getLogData_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogData_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getLogData.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > _promise_getLogData;

    public:
        struct PromisegetLogFileList
        {
        public:
            kant::Int32 _ret;
            vector<std::string> logFileList;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetLogFileList > PromisegetLogFileListPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > &promise)
        : _promise_getLogFileList(promise)
        {}
        
        virtual void callback_getLogFileList(const AdminRegPrxCallbackPromise::PromisegetLogFileListPtr &ptr)
        {
            _promise_getLogFileList.setValue(ptr);
        }
        virtual void callback_getLogFileList_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogFileList_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getLogFileList.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > _promise_getLogFileList;

    public:
        struct PromisegetNodeLoad
        {
        public:
            kant::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetNodeLoad > PromisegetNodeLoadPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > &promise)
        : _promise_getNodeLoad(promise)
        {}
        
        virtual void callback_getNodeLoad(const AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr &ptr)
        {
            _promise_getNodeLoad.setValue(ptr);
        }
        virtual void callback_getNodeLoad_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeLoad_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getNodeLoad.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > _promise_getNodeLoad;

    public:
        struct PromisegetNodeVesion
        {
        public:
            kant::Int32 _ret;
            std::string version;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetNodeVesion > PromisegetNodeVesionPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > &promise)
        : _promise_getNodeVesion(promise)
        {}
        
        virtual void callback_getNodeVesion(const AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr &ptr)
        {
            _promise_getNodeVesion.setValue(ptr);
        }
        virtual void callback_getNodeVesion_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeVesion_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getNodeVesion.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > _promise_getNodeVesion;

    public:
        struct PromisegetPatchPercent
        {
        public:
            kant::Int32 _ret;
            kant::PatchInfo tPatchInfo;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getPatchPercent.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetProfileTemplate
        {
        public:
            kant::Int32 _ret;
            std::string profileTemplate;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetProfileTemplate > PromisegetProfileTemplatePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > &promise)
        : _promise_getProfileTemplate(promise)
        {}
        
        virtual void callback_getProfileTemplate(const AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr &ptr)
        {
            _promise_getProfileTemplate.setValue(ptr);
        }
        virtual void callback_getProfileTemplate_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getProfileTemplate_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getProfileTemplate.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > _promise_getProfileTemplate;

    public:
        struct PromisegetServerProfileTemplate
        {
        public:
            kant::Int32 _ret;
            std::string profileTemplate;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplate > PromisegetServerProfileTemplatePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > &promise)
        : _promise_getServerProfileTemplate(promise)
        {}
        
        virtual void callback_getServerProfileTemplate(const AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr &ptr)
        {
            _promise_getServerProfileTemplate.setValue(ptr);
        }
        virtual void callback_getServerProfileTemplate_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerProfileTemplate_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getServerProfileTemplate.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > _promise_getServerProfileTemplate;

    public:
        struct PromisegetServerState
        {
        public:
            kant::Int32 _ret;
            kant::ServerStateDesc state;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetServerState > PromisegetServerStatePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > &promise)
        : _promise_getServerState(promise)
        {}
        
        virtual void callback_getServerState(const AdminRegPrxCallbackPromise::PromisegetServerStatePtr &ptr)
        {
            _promise_getServerState.setValue(ptr);
        }
        virtual void callback_getServerState_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerState_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getServerState.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > _promise_getServerState;

    public:
        struct PromisegetServers
        {
        public:
            kant::Int32 _ret;
            vector<kant::FrameworkServer> servers;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetServers > PromisegetServersPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetServersPtr > &promise)
        : _promise_getServers(promise)
        {}
        
        virtual void callback_getServers(const AdminRegPrxCallbackPromise::PromisegetServersPtr &ptr)
        {
            _promise_getServers.setValue(ptr);
        }
        virtual void callback_getServers_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getServers_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getServers.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetServersPtr > _promise_getServers;

    public:
        struct PromisegetTaskHistory
        {
        public:
            kant::Int32 _ret;
            vector<kant::TaskRsp> taskRsps;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetTaskHistory > PromisegetTaskHistoryPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > &promise)
        : _promise_getTaskHistory(promise)
        {}
        
        virtual void callback_getTaskHistory(const AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr &ptr)
        {
            _promise_getTaskHistory.setValue(ptr);
        }
        virtual void callback_getTaskHistory_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getTaskHistory_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getTaskHistory.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > _promise_getTaskHistory;

    public:
        struct PromisegetTaskRsp
        {
        public:
            kant::Int32 _ret;
            kant::TaskRsp taskRsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetTaskRsp > PromisegetTaskRspPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > &promise)
        : _promise_getTaskRsp(promise)
        {}
        
        virtual void callback_getTaskRsp(const AdminRegPrxCallbackPromise::PromisegetTaskRspPtr &ptr)
        {
            _promise_getTaskRsp.setValue(ptr);
        }
        virtual void callback_getTaskRsp_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getTaskRsp_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getTaskRsp.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > _promise_getTaskRsp;

    public:
        struct PromisegetVersion
        {
        public:
            kant::Int32 _ret;
            std::string version;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisegetVersion > PromisegetVersionPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisegetVersionPtr > &promise)
        : _promise_getVersion(promise)
        {}
        
        virtual void callback_getVersion(const AdminRegPrxCallbackPromise::PromisegetVersionPtr &ptr)
        {
            _promise_getVersion.setValue(ptr);
        }
        virtual void callback_getVersion_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getVersion_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getVersion.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisegetVersionPtr > _promise_getVersion;

    public:
        struct PromiseloadServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const AdminRegPrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_loadServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const AdminRegPrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_notifyServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepingNode
        {
        public:
            kant::Bool _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisepingNode > PromisepingNodePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > &promise)
        : _promise_pingNode(promise)
        {}
        
        virtual void callback_pingNode(const AdminRegPrxCallbackPromise::PromisepingNodePtr &ptr)
        {
            _promise_pingNode.setValue(ptr);
        }
        virtual void callback_pingNode_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:pingNode_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_pingNode.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > _promise_pingNode;

    public:
        struct PromiserestartServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiserestartServer > PromiserestartServerPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > &promise)
        : _promise_restartServer(promise)
        {}
        
        virtual void callback_restartServer(const AdminRegPrxCallbackPromise::PromiserestartServerPtr &ptr)
        {
            _promise_restartServer.setValue(ptr);
        }
        virtual void callback_restartServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:restartServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_restartServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > _promise_restartServer;

    public:
        struct PromisesetTaskItemInfo
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisesetTaskItemInfo > PromisesetTaskItemInfoPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > &promise)
        : _promise_setTaskItemInfo(promise)
        {}
        
        virtual void callback_setTaskItemInfo(const AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr &ptr)
        {
            _promise_setTaskItemInfo.setValue(ptr);
        }
        virtual void callback_setTaskItemInfo_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:setTaskItemInfo_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_setTaskItemInfo.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > _promise_setTaskItemInfo;

    public:
        struct PromiseshutdownNode
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiseshutdownNode > PromiseshutdownNodePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > &promise)
        : _promise_shutdownNode(promise)
        {}
        
        virtual void callback_shutdownNode(const AdminRegPrxCallbackPromise::PromiseshutdownNodePtr &ptr)
        {
            _promise_shutdownNode.setValue(ptr);
        }
        virtual void callback_shutdownNode_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdownNode_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_shutdownNode.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > _promise_shutdownNode;

    public:
        struct PromisestartServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const AdminRegPrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_startServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const AdminRegPrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_stopServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        struct Promiseundeploy
        {
        public:
            kant::Int32 _ret;
            std::string log;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::Promiseundeploy > PromiseundeployPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > &promise)
        : _promise_undeploy(promise)
        {}
        
        virtual void callback_undeploy(const AdminRegPrxCallbackPromise::PromiseundeployPtr &ptr)
        {
            _promise_undeploy.setValue(ptr);
        }
        virtual void callback_undeploy_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:undeploy_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_undeploy.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > _promise_undeploy;

    public:
        struct PromiseupdatePatchLog
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiseupdatePatchLog > PromiseupdatePatchLogPtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > &promise)
        : _promise_updatePatchLog(promise)
        {}
        
        virtual void callback_updatePatchLog(const AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr &ptr)
        {
            _promise_updatePatchLog.setValue(ptr);
        }
        virtual void callback_updatePatchLog_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:updatePatchLog_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_updatePatchLog.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > _promise_updatePatchLog;

    public:
        struct PromiseupdateServerFlowState
        {
        public:
            kant::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< AdminRegPrxCallbackPromise::PromiseupdateServerFlowState > PromiseupdateServerFlowStatePtr;

        AdminRegPrxCallbackPromise(const kant::Promise< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > &promise)
        : _promise_updateServerFlowState(promise)
        {}
        
        virtual void callback_updateServerFlowState(const AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr &ptr)
        {
            _promise_updateServerFlowState.setValue(ptr);
        }
        virtual void callback_updateServerFlowState_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:updateServerFlowState_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_updateServerFlowState.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > _promise_updateServerFlowState;

    public:
        virtual int onDispatch(kant::ReqMessagePtr msg)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "deletePatchFile",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog",
                "updateServerFlowState"
            };

            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+35, string(msg->request.sFuncName));
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiseaddTaskReq>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addTaskReq_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addTaskReq_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_addTaskReq(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisebatchPatchPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisebatchPatch>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_batchPatch_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_batchPatch_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_batchPatch(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_checkDockerRegistry_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisecheckDockerRegistry>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_checkDockerRegistry_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkDockerRegistry_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_checkDockerRegistry(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_checkServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisecheckServerPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisecheckServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_checkServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_deletePatchFile_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisedeletePatchFile>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_deletePatchFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_deletePatchFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_deletePatchFile(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_dockerPull_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisedockerPullPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisedockerPull>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_dockerPull_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_dockerPull_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_dockerPull(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiseforceDockerLogin>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_forceDockerLogin(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetAllApplicationNames>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllApplicationNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllApplicationNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getAllApplicationNames(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetAllNodeNames>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllNodeNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllNodeNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getAllNodeNames(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetAllServerIds>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllServerIds_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllServerIds_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getAllServerIds(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetClientIpPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetClientIp>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->sClientIp, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getClientIp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getClientIp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getClientIp(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetGroupIdPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetGroupId>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->groupId, 2, true);
                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getGroupId_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getGroupId_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getGroupId(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogData_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetLogDataPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetLogData>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getLogData(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetLogFileListPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetLogFileList>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->logFileList, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getLogFileList(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetNodeLoad>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getNodeLoad(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetNodeVesion>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->version, 2, true);
                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeVesion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeVesion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getNodeVesion(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetPatchPercent>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tPatchInfo, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getPatchPercent(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetProfileTemplate>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->profileTemplate, 2, true);
                        _is.read(ptr->resultDesc, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getProfileTemplate(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetServerProfileTemplate>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->profileTemplate, 4, true);
                        _is.read(ptr->resultDesc, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getServerProfileTemplate(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerStatePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetServerState>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->state, 4, true);
                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getServerState(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServers_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServersPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetServers>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->servers, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getServers(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetTaskHistory>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->taskRsps, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskHistory_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskHistory_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getTaskHistory(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetTaskRspPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetTaskRsp>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->taskRsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskRsp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskRsp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getTaskRsp(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 23:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getVersion_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetVersionPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisegetVersion>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->version, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getVersion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getVersion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getVersion(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 24:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseloadServerPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiseloadServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_loadServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 25:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisenotifyServerPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisenotifyServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_notifyServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 26:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_pingNode_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisepingNodePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisepingNode>();

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_pingNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_pingNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_pingNode(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 27:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_restartServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiserestartServerPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiserestartServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_restartServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_restartServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_restartServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 28:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisesetTaskItemInfo>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_setTaskItemInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_setTaskItemInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_setTaskItemInfo(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 29:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseshutdownNodePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiseshutdownNode>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdownNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdownNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_shutdownNode(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 30:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisestartServerPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisestartServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_startServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 31:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromisestopServerPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromisestopServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_stopServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 32:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_undeploy_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseundeployPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::Promiseundeploy>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->log, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_undeploy_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_undeploy_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_undeploy(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 33:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiseupdatePatchLog>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updatePatchLog_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updatePatchLog_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_updatePatchLog(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 34:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_updateServerFlowState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr ptr = std::make_shared<AdminRegPrxCallbackPromise::PromiseupdateServerFlowState>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updateServerFlowState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updateServerFlowState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_updateServerFlowState(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }

    };
    typedef std::shared_ptr<AdminRegPrxCallbackPromise> AdminRegPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class AdminRegCoroPrxCallback: public AdminRegPrxCallback
    {
    public:
        virtual ~AdminRegCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(kant::ReqMessagePtr msg)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "deletePatchFile",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog",
                "updateServerFlowState"
            };

            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+35, string(msg->request.sFuncName));
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_addTaskReq(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addTaskReq_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addTaskReq_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response->context);

                        callback_batchPatch(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_batchPatch_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_batchPatch_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_checkDockerRegistry_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_checkDockerRegistry(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkDockerRegistry_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkDockerRegistry_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_checkServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_checkServer(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_checkServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_checkServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_deletePatchFile_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_deletePatchFile(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_deletePatchFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_deletePatchFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_dockerPull_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_dockerPull(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_dockerPull_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_dockerPull_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response->context);

                        callback_forceDockerLogin(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        vector<std::string> _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response->context);

                        callback_getAllApplicationNames(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllApplicationNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllApplicationNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        vector<std::string> _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response->context);

                        callback_getAllNodeNames(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllNodeNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllNodeNames_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        vector<vector<std::string> > _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response->context);

                        callback_getAllServerIds(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllServerIds_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllServerIds_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string sClientIp;
                        _is.read(sClientIp, 1, true);
                        setResponseContext(msg->response->context);

                        callback_getClientIp(_ret, sClientIp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getClientIp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getClientIp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        kant::Int32 groupId;
                        _is.read(groupId, 2, true);
                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getGroupId(_ret, groupId, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getGroupId_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getGroupId_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogData_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 6, true);
                        setResponseContext(msg->response->context);

                        callback_getLogData(_ret, fileData);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> logFileList;
                        _is.read(logFileList, 4, true);
                        setResponseContext(msg->response->context);

                        callback_getLogFileList(_ret, logFileList);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 5, true);
                        setResponseContext(msg->response->context);

                        callback_getNodeLoad(_ret, fileData);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string version;
                        _is.read(version, 2, true);
                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getNodeVesion(_ret, version, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeVesion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeVesion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        kant::PatchInfo tPatchInfo;
                        _is.read(tPatchInfo, 4, true);
                        setResponseContext(msg->response->context);

                        callback_getPatchPercent(_ret, tPatchInfo);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string profileTemplate;
                        _is.read(profileTemplate, 2, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getProfileTemplate(_ret, profileTemplate, resultDesc);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string profileTemplate;
                        _is.read(profileTemplate, 4, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 5, true);
                        setResponseContext(msg->response->context);

                        callback_getServerProfileTemplate(_ret, profileTemplate, resultDesc);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerProfileTemplate_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        kant::ServerStateDesc state;
                        _is.read(state, 4, true);
                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(msg->response->context);

                        callback_getServerState(_ret, state, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServers_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<kant::FrameworkServer> servers;
                        _is.read(servers, 1, true);
                        setResponseContext(msg->response->context);

                        callback_getServers(_ret, servers);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<kant::TaskRsp> taskRsps;
                        _is.read(taskRsps, 4, true);
                        setResponseContext(msg->response->context);

                        callback_getTaskHistory(_ret, taskRsps);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskHistory_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskHistory_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        kant::TaskRsp taskRsp;
                        _is.read(taskRsp, 2, true);
                        setResponseContext(msg->response->context);

                        callback_getTaskRsp(_ret, taskRsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskRsp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskRsp_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 23:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getVersion_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string version;
                        _is.read(version, 1, true);
                        setResponseContext(msg->response->context);

                        callback_getVersion(_ret, version);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getVersion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getVersion_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 24:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_loadServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 25:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(msg->response->context);

                        callback_notifyServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 26:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_pingNode_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response->context);

                        callback_pingNode(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_pingNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_pingNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 27:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_restartServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_restartServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_restartServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_restartServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 28:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_setTaskItemInfo(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_setTaskItemInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_setTaskItemInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 29:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response->context);

                        callback_shutdownNode(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdownNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdownNode_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 30:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_startServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 31:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_stopServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 32:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_undeploy_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string log;
                        _is.read(log, 5, true);
                        setResponseContext(msg->response->context);

                        callback_undeploy(_ret, log);

                    }
                    catch(std::exception &ex)
                    {
                        callback_undeploy_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_undeploy_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 33:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_updatePatchLog(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updatePatchLog_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updatePatchLog_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 34:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_updateServerFlowState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_updateServerFlowState(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updateServerFlowState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updateServerFlowState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef std::shared_ptr<AdminRegCoroPrxCallback> AdminRegCoroPrxCallbackPtr;

    /* proxy for client */
    class AdminRegProxy : public kant::ServantProxy
    {
    public:
        typedef map<string, string> KANT_CONTEXT;
        AdminRegProxy(Communicator* pCommunicator, const string& name, const string& setName)
                : ServantProxy(pCommunicator, name, setName) {}

        kant::Int32 addTaskReq(const kant::TaskReq & taskReq,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"addTaskReq", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_addTaskReq(AdminRegPrxCallbackPtr callback,const kant::TaskReq &taskReq,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"addTaskReq", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > promise_async_addTaskReq(const kant::TaskReq &taskReq,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"addTaskReq", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_addTaskReq(AdminRegCoroPrxCallbackPtr callback,const kant::TaskReq &taskReq,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"addTaskReq", _os, context, _mStatus, callback, true);
        }

        kant::Int32 batchPatch(const kant::PatchRequest & req,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"batchPatch", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_batchPatch(AdminRegPrxCallbackPtr callback,const kant::PatchRequest &req,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"batchPatch", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > promise_async_batchPatch(const kant::PatchRequest &req,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"batchPatch", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_batchPatch(AdminRegCoroPrxCallbackPtr callback,const kant::PatchRequest &req,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"batchPatch", _os, context, _mStatus, callback, true);
        }

        kant::Int32 checkDockerRegistry(const std::string & registry,const std::string & userName,const std::string & password,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"checkDockerRegistry", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_checkDockerRegistry(AdminRegPrxCallbackPtr callback,const std::string &registry,const std::string &userName,const std::string &password,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"checkDockerRegistry", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > promise_async_checkDockerRegistry(const std::string &registry,const std::string &userName,const std::string &password,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisecheckDockerRegistryPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"checkDockerRegistry", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_checkDockerRegistry(AdminRegCoroPrxCallbackPtr callback,const std::string &registry,const std::string &userName,const std::string &password,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(registry, 1);
            _os.write(userName, 2);
            _os.write(password, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"checkDockerRegistry", _os, context, _mStatus, callback, true);
        }

        kant::Int32 checkServer(const kant::FrameworkServer & server,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"checkServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_checkServer(AdminRegPrxCallbackPtr callback,const kant::FrameworkServer &server,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"checkServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisecheckServerPtr > promise_async_checkServer(const kant::FrameworkServer &server,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisecheckServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"checkServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_checkServer(AdminRegCoroPrxCallbackPtr callback,const kant::FrameworkServer &server,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(server, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"checkServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 deletePatchFile(const std::string & application,const std::string & serverName,const std::string & patchFile,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"deletePatchFile", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_deletePatchFile(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &patchFile,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"deletePatchFile", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > promise_async_deletePatchFile(const std::string &application,const std::string &serverName,const std::string &patchFile,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisedeletePatchFilePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"deletePatchFile", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_deletePatchFile(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &patchFile,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(patchFile, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"deletePatchFile", _os, context, _mStatus, callback, true);
        }

        kant::Int32 dockerPull(const std::string & baseImageId,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"dockerPull", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_dockerPull(AdminRegPrxCallbackPtr callback,const std::string &baseImageId,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"dockerPull", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisedockerPullPtr > promise_async_dockerPull(const std::string &baseImageId,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisedockerPullPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"dockerPull", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_dockerPull(AdminRegCoroPrxCallbackPtr callback,const std::string &baseImageId,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(baseImageId, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"dockerPull", _os, context, _mStatus, callback, true);
        }

        kant::Int32 forceDockerLogin(const std::string & nodeName,vector<std::string> &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_forceDockerLogin(AdminRegPrxCallbackPtr callback,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > promise_async_forceDockerLogin(const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseforceDockerLoginPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_forceDockerLogin(AdminRegCoroPrxCallbackPtr callback,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(nodeName, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus, callback, true);
        }

        vector<std::string> getAllApplicationNames(std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getAllApplicationNames", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            vector<std::string> _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllApplicationNames(AdminRegPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllApplicationNames", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > promise_async_getAllApplicationNames(const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllApplicationNames", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllApplicationNames(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllApplicationNames", _os, context, _mStatus, callback, true);
        }

        vector<std::string> getAllNodeNames(std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getAllNodeNames", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            vector<std::string> _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllNodeNames(AdminRegPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllNodeNames", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > promise_async_getAllNodeNames(const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllNodeNames", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllNodeNames(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllNodeNames", _os, context, _mStatus, callback, true);
        }

        vector<vector<std::string> > getAllServerIds(std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getAllServerIds", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            vector<vector<std::string> > _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllServerIds(AdminRegPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllServerIds", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > promise_async_getAllServerIds(const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllServerIds", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllServerIds(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getAllServerIds", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getClientIp(std::string &sClientIp,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(sClientIp, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getClientIp", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(sClientIp, 1, true);
            return _ret;
        }

        void async_getClientIp(AdminRegPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getClientIp", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > promise_async_getClientIp(const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getClientIp", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getClientIp(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getClientIp", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getGroupId(const std::string & ip,kant::Int32 &groupId,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(ip, 1);
            _os.write(groupId, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getGroupId", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(groupId, 2, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getGroupId(AdminRegPrxCallbackPtr callback,const std::string &ip,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getGroupId", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > promise_async_getGroupId(const std::string &ip,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getGroupId", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getGroupId(AdminRegCoroPrxCallbackPtr callback,const std::string &ip,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getGroupId", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & logFile,const std::string & cmd,std::string &fileData,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            _os.write(fileData, 6);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getLogData", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 6, true);
            return _ret;
        }

        void async_getLogData(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogData", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > promise_async_getLogData(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &logFile,const std::string &cmd,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetLogDataPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogData", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogData(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFile, 4);
            _os.write(cmd, 5);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogData", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getLogFileList(const std::string & application,const std::string & serverName,const std::string & nodeName,vector<std::string> &logFileList,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(logFileList, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(logFileList, 4, true);
            return _ret;
        }

        void async_getLogFileList(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > promise_async_getLogFileList(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetLogFileListPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogFileList(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getNodeLoad(const std::string & application,const std::string & serverName,const std::string & nodeName,kant::Int32 pid,std::string &fileData,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            _os.write(fileData, 5);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 5, true);
            return _ret;
        }

        void async_getNodeLoad(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,kant::Int32 pid,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > promise_async_getNodeLoad(const std::string &application,const std::string &serverName,const std::string &nodeName,kant::Int32 pid,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetNodeLoadPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeLoad(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,kant::Int32 pid,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(pid, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getNodeVesion(const std::string & name,std::string &version,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            _os.write(version, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getNodeVesion", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(version, 2, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getNodeVesion(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeVesion", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > promise_async_getNodeVesion(const std::string &name,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeVesion", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeVesion(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeVesion", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getPatchPercent(const std::string & application,const std::string & serverName,const std::string & nodeName,kant::PatchInfo &tPatchInfo,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(tPatchInfo, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tPatchInfo, 4, true);
            return _ret;
        }

        void async_getPatchPercent(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getProfileTemplate(const std::string & profileName,std::string &profileTemplate,std::string &resultDesc,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(profileName, 1);
            _os.write(profileTemplate, 2);
            _os.write(resultDesc, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getProfileTemplate", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(profileTemplate, 2, true);
            _is.read(resultDesc, 3, true);
            return _ret;
        }

        void async_getProfileTemplate(AdminRegPrxCallbackPtr callback,const std::string &profileName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getProfileTemplate", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > promise_async_getProfileTemplate(const std::string &profileName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getProfileTemplate", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getProfileTemplate(AdminRegCoroPrxCallbackPtr callback,const std::string &profileName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getProfileTemplate", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getServerProfileTemplate(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &profileTemplate,std::string &resultDesc,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(profileTemplate, 4);
            _os.write(resultDesc, 5);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getServerProfileTemplate", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(profileTemplate, 4, true);
            _is.read(resultDesc, 5, true);
            return _ret;
        }

        void async_getServerProfileTemplate(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerProfileTemplate", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > promise_async_getServerProfileTemplate(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerProfileTemplate", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerProfileTemplate(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerProfileTemplate", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getServerState(const std::string & application,const std::string & serverName,const std::string & nodeName,kant::ServerStateDesc &state,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(state, 4);
            _os.write(result, 5);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getServerState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(state, 4, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_getServerState(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerState", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > promise_async_getServerState(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerState(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerState", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getServers(vector<kant::FrameworkServer> &servers,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(servers, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getServers", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(servers, 1, true);
            return _ret;
        }

        void async_getServers(AdminRegPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServers", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetServersPtr > promise_async_getServers(const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetServersPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServers", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServers(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServers", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getTaskHistory(const std::string & application,const std::string & serverName,const std::string & command,vector<kant::TaskRsp> &taskRsps,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            _os.write(taskRsps, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getTaskHistory", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(taskRsps, 4, true);
            return _ret;
        }

        void async_getTaskHistory(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getTaskHistory", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > promise_async_getTaskHistory(const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getTaskHistory", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getTaskHistory(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getTaskHistory", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getTaskRsp(const std::string & taskNo,kant::TaskRsp &taskRsp,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            _os.write(taskRsp, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getTaskRsp", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(taskRsp, 2, true);
            return _ret;
        }

        void async_getTaskRsp(AdminRegPrxCallbackPtr callback,const std::string &taskNo,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getTaskRsp", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > promise_async_getTaskRsp(const std::string &taskNo,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getTaskRsp", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getTaskRsp(AdminRegCoroPrxCallbackPtr callback,const std::string &taskNo,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getTaskRsp", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getVersion(std::string &version,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(version, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getVersion", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(version, 1, true);
            return _ret;
        }

        void async_getVersion(AdminRegPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getVersion", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisegetVersionPtr > promise_async_getVersion(const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisegetVersionPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getVersion", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getVersion(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getVersion", _os, context, _mStatus, callback, true);
        }

        kant::Int32 loadServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"loadServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_loadServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"loadServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"loadServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"loadServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & command,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            _os.write(result, 5);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_notifyServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus, callback, true);
        }

        kant::Bool pingNode(const std::string & name,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"pingNode", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_pingNode(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"pingNode", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisepingNodePtr > promise_async_pingNode(const std::string &name,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"pingNode", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_pingNode(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"pingNode", _os, context, _mStatus, callback, true);
        }

        kant::Int32 restartServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"restartServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_restartServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"restartServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiserestartServerPtr > promise_async_restartServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"restartServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_restartServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"restartServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 setTaskItemInfo(const std::string & itemNo,const map<std::string, std::string> & info,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"setTaskItemInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_setTaskItemInfo(AdminRegPrxCallbackPtr callback,const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"setTaskItemInfo", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > promise_async_setTaskItemInfo(const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"setTaskItemInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_setTaskItemInfo(AdminRegCoroPrxCallbackPtr callback,const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"setTaskItemInfo", _os, context, _mStatus, callback, true);
        }

        kant::Int32 shutdownNode(const std::string & name,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"shutdownNode", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_shutdownNode(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"shutdownNode", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > promise_async_shutdownNode(const std::string &name,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"shutdownNode", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdownNode(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"shutdownNode", _os, context, _mStatus, callback, true);
        }

        kant::Int32 startServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"startServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_startServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"startServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"startServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"startServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 stopServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"stopServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_stopServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 undeploy(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & user,std::string &log,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            _os.write(log, 5);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"undeploy", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(log, 5, true);
            return _ret;
        }

        void async_undeploy(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"undeploy", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseundeployPtr > promise_async_undeploy(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"undeploy", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_undeploy(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"undeploy", _os, context, _mStatus, callback, true);
        }

        kant::Int32 updatePatchLog(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & patchId,const std::string & user,const std::string & patchType,kant::Bool succ,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"updatePatchLog", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_updatePatchLog(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,kant::Bool succ,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"updatePatchLog", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > promise_async_updatePatchLog(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,kant::Bool succ,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"updatePatchLog", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_updatePatchLog(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,kant::Bool succ,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"updatePatchLog", _os, context, _mStatus, callback, true);
        }

        kant::Int32 updateServerFlowState(const std::string & application,const std::string & serverName,const vector<std::string> & nodeList,kant::Bool bActive,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"updateServerFlowState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_updateServerFlowState(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const vector<std::string> &nodeList,kant::Bool bActive,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"updateServerFlowState", _os, context, _mStatus, callback);
        }
        
        kant::Future< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > promise_async_updateServerFlowState(const std::string &application,const std::string &serverName,const vector<std::string> &nodeList,kant::Bool bActive,const map<string, string>& context)
        {
            kant::Promise< AdminRegPrxCallbackPromise::PromiseupdateServerFlowStatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = std::make_shared<AdminRegPrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"updateServerFlowState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_updateServerFlowState(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const vector<std::string> &nodeList,kant::Bool bActive,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeList, 3);
            _os.write(bActive, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"updateServerFlowState", _os, context, _mStatus, callback, true);
        }

        AdminRegProxy* kant_hash(int64_t key)
        {
            return (AdminRegProxy*)ServantProxy::kant_hash(key);
        }

        AdminRegProxy* kant_consistent_hash(int64_t key)
        {
            return (AdminRegProxy*)ServantProxy::kant_consistent_hash(key);
        }

        AdminRegProxy* kant_open_trace(bool traceParam = false)
        {
            return (AdminRegProxy*)ServantProxy::kant_open_trace(traceParam);
        }

        AdminRegProxy* kant_set_timeout(int msecond)
        {
            return (AdminRegProxy*)ServantProxy::kant_set_timeout(msecond);
        }

        static const char* kant_prxname() { return "AdminRegProxy"; }
    };
    typedef std::shared_ptr<AdminRegProxy> AdminRegPrx;

    /* servant for server */
    class AdminReg : public kant::Servant
    {
    public:
        virtual ~AdminReg(){}
        virtual kant::Int32 addTaskReq(const kant::TaskReq & taskReq,kant::KantCurrentPtr current) = 0;
        static void async_response_addTaskReq(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 batchPatch(const kant::PatchRequest & req,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_batchPatch(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 checkDockerRegistry(const std::string & registry,const std::string & userName,const std::string & password,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_checkDockerRegistry(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 checkServer(const kant::FrameworkServer & server,kant::KantCurrentPtr current) = 0;
        static void async_response_checkServer(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 deletePatchFile(const std::string & application,const std::string & serverName,const std::string & patchFile,kant::KantCurrentPtr current) = 0;
        static void async_response_deletePatchFile(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 dockerPull(const std::string & baseImageId,kant::KantCurrentPtr current) = 0;
        static void async_response_dockerPull(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 forceDockerLogin(const std::string & nodeName,vector<std::string> &result,kant::KantCurrentPtr current) = 0;
        static void async_response_forceDockerLogin(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<std::string> &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual vector<std::string> getAllApplicationNames(std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getAllApplicationNames(kant::KantCurrentPtr current, const vector<std::string> &_ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual vector<std::string> getAllNodeNames(std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getAllNodeNames(kant::KantCurrentPtr current, const vector<std::string> &_ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual vector<vector<std::string> > getAllServerIds(std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getAllServerIds(kant::KantCurrentPtr current, const vector<vector<std::string> > &_ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getClientIp(std::string &sClientIp,kant::KantCurrentPtr current) = 0;
        static void async_response_getClientIp(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &sClientIp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("sClientIp", sClientIp);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["sClientIp"] = kant::JsonOutput::writeJson(sClientIp);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(sClientIp, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getGroupId(const std::string & ip,kant::Int32 &groupId,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getGroupId(kant::KantCurrentPtr current, kant::Int32 _ret, kant::Int32 groupId, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("groupId", groupId);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["groupId"] = kant::JsonOutput::writeJson(groupId);
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(groupId, 2);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & logFile,const std::string & cmd,std::string &fileData,kant::KantCurrentPtr current) = 0;
        static void async_response_getLogData(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &fileData)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 6);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getLogFileList(const std::string & application,const std::string & serverName,const std::string & nodeName,vector<std::string> &logFileList,kant::KantCurrentPtr current) = 0;
        static void async_response_getLogFileList(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<std::string> &logFileList)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("logFileList", logFileList);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["logFileList"] = kant::JsonOutput::writeJson(logFileList);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(logFileList, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getNodeLoad(const std::string & application,const std::string & serverName,const std::string & nodeName,kant::Int32 pid,std::string &fileData,kant::KantCurrentPtr current) = 0;
        static void async_response_getNodeLoad(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &fileData)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 5);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getNodeVesion(const std::string & name,std::string &version,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getNodeVesion(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &version, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("version", version);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["version"] = kant::JsonOutput::writeJson(version);
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(version, 2);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getPatchPercent(const std::string & application,const std::string & serverName,const std::string & nodeName,kant::PatchInfo &tPatchInfo,kant::KantCurrentPtr current) = 0;
        static void async_response_getPatchPercent(kant::KantCurrentPtr current, kant::Int32 _ret, const kant::PatchInfo &tPatchInfo)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("tPatchInfo", tPatchInfo);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["tPatchInfo"] = kant::JsonOutput::writeJson(tPatchInfo);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getProfileTemplate(const std::string & profileName,std::string &profileTemplate,std::string &resultDesc,kant::KantCurrentPtr current) = 0;
        static void async_response_getProfileTemplate(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("profileTemplate", profileTemplate);
                kantAttr.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["profileTemplate"] = kant::JsonOutput::writeJson(profileTemplate);
                _p->value["resultDesc"] = kant::JsonOutput::writeJson(resultDesc);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 2);

                _os.write(resultDesc, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getServerProfileTemplate(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &profileTemplate,std::string &resultDesc,kant::KantCurrentPtr current) = 0;
        static void async_response_getServerProfileTemplate(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("profileTemplate", profileTemplate);
                kantAttr.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["profileTemplate"] = kant::JsonOutput::writeJson(profileTemplate);
                _p->value["resultDesc"] = kant::JsonOutput::writeJson(resultDesc);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 4);

                _os.write(resultDesc, 5);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getServerState(const std::string & application,const std::string & serverName,const std::string & nodeName,kant::ServerStateDesc &state,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getServerState(kant::KantCurrentPtr current, kant::Int32 _ret, const kant::ServerStateDesc &state, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("state", state);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["state"] = kant::JsonOutput::writeJson(state);
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(state, 4);

                _os.write(result, 5);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getServers(vector<kant::FrameworkServer> &servers,kant::KantCurrentPtr current) = 0;
        static void async_response_getServers(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<kant::FrameworkServer> &servers)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("servers", servers);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["servers"] = kant::JsonOutput::writeJson(servers);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(servers, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getTaskHistory(const std::string & application,const std::string & serverName,const std::string & command,vector<kant::TaskRsp> &taskRsps,kant::KantCurrentPtr current) = 0;
        static void async_response_getTaskHistory(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<kant::TaskRsp> &taskRsps)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("taskRsps", taskRsps);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["taskRsps"] = kant::JsonOutput::writeJson(taskRsps);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(taskRsps, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getTaskRsp(const std::string & taskNo,kant::TaskRsp &taskRsp,kant::KantCurrentPtr current) = 0;
        static void async_response_getTaskRsp(kant::KantCurrentPtr current, kant::Int32 _ret, const kant::TaskRsp &taskRsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("taskRsp", taskRsp);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["taskRsp"] = kant::JsonOutput::writeJson(taskRsp);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(taskRsp, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getVersion(std::string &version,kant::KantCurrentPtr current) = 0;
        static void async_response_getVersion(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &version)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("version", version);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["version"] = kant::JsonOutput::writeJson(version);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(version, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 loadServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_loadServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & command,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_notifyServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 5);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Bool pingNode(const std::string & name,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_pingNode(kant::KantCurrentPtr current, kant::Bool _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 restartServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_restartServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 setTaskItemInfo(const std::string & itemNo,const map<std::string, std::string> & info,kant::KantCurrentPtr current) = 0;
        static void async_response_setTaskItemInfo(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 shutdownNode(const std::string & name,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_shutdownNode(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 startServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_startServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 stopServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_stopServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 undeploy(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & user,std::string &log,kant::KantCurrentPtr current) = 0;
        static void async_response_undeploy(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &log)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("log", log);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["log"] = kant::JsonOutput::writeJson(log);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(log, 5);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 updatePatchLog(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & patchId,const std::string & user,const std::string & patchType,kant::Bool succ,kant::KantCurrentPtr current) = 0;
        static void async_response_updatePatchLog(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 updateServerFlowState(const std::string & application,const std::string & serverName,const vector<std::string> & nodeList,kant::Bool bActive,kant::KantCurrentPtr current) = 0;
        static void async_response_updateServerFlowState(kant::KantCurrentPtr current, kant::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(kant::KantCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __kant__AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "checkDockerRegistry",
                "checkServer",
                "deletePatchFile",
                "dockerPull",
                "forceDockerLogin",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getServers",
                "getTaskHistory",
                "getTaskRsp",
                "getVersion",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog",
                "updateServerFlowState"
            };

            pair<string*, string*> r = equal_range(__kant__AdminReg_all, __kant__AdminReg_all+35, _current->getFuncName());
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __kant__AdminReg_all)
            {
                case 0:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    kant::TaskReq taskReq;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("taskReq", taskReq);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(taskReq, _jsonPtr->value["taskReq"], true);
                    }
                    else
                    {
                        _is.read(taskReq, 1, true);
                    }
                    kant::Int32 _ret = addTaskReq(taskReq, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    kant::PatchRequest req;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("req", req);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(result, 2, false);
                    }
                    kant::Int32 _ret = batchPatch(req,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string registry;
                    std::string userName;
                    std::string password;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("registry", registry);
                        kantAttr.get("userName", userName);
                        kantAttr.get("password", password);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(registry, _jsonPtr->value["registry"], true);
                        kant::JsonInput::readJson(userName, _jsonPtr->value["userName"], true);
                        kant::JsonInput::readJson(password, _jsonPtr->value["password"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(registry, 1, true);
                        _is.read(userName, 2, true);
                        _is.read(password, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = checkDockerRegistry(registry,userName,password,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    kant::FrameworkServer server;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("server", server);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(server, _jsonPtr->value["server"], true);
                    }
                    else
                    {
                        _is.read(server, 1, true);
                    }
                    kant::Int32 _ret = checkServer(server, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string patchFile;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("patchFile", patchFile);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(patchFile, _jsonPtr->value["patchFile"], true);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(patchFile, 3, true);
                    }
                    kant::Int32 _ret = deletePatchFile(application,serverName,patchFile, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string baseImageId;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("baseImageId", baseImageId);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(baseImageId, _jsonPtr->value["baseImageId"], true);
                    }
                    else
                    {
                        _is.read(baseImageId, 1, true);
                    }
                    kant::Int32 _ret = dockerPull(baseImageId, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string nodeName;
                    vector<std::string> result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(nodeName, 1, true);
                        _is.read(result, 2, false);
                    }
                    kant::Int32 _ret = forceDockerLogin(nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<std::string> _ret = getAllApplicationNames(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<std::string> _ret = getAllNodeNames(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<vector<std::string> > _ret = getAllServerIds(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sClientIp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("sClientIp", sClientIp, sClientIp);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(sClientIp, _jsonPtr->value["sClientIp"], false);
                    }
                    else
                    {
                        _is.read(sClientIp, 1, false);
                    }
                    kant::Int32 _ret = getClientIp(sClientIp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("sClientIp", sClientIp);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["sClientIp"] = kant::JsonOutput::writeJson(sClientIp);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(sClientIp, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string ip;
                    kant::Int32 groupId;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("ip", ip);
                        kantAttr.getByDefault("groupId", groupId, groupId);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(ip, _jsonPtr->value["ip"], true);
                        kant::JsonInput::readJson(groupId, _jsonPtr->value["groupId"], false);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(ip, 1, true);
                        _is.read(groupId, 2, false);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = getGroupId(ip,groupId,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("groupId", groupId);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["groupId"] = kant::JsonOutput::writeJson(groupId);
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(groupId, 2);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string logFile;
                    std::string cmd;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.get("logFile", logFile);
                        kantAttr.get("cmd", cmd);
                        kantAttr.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(logFile, _jsonPtr->value["logFile"], true);
                        kant::JsonInput::readJson(cmd, _jsonPtr->value["cmd"], true);
                        kant::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(logFile, 4, true);
                        _is.read(cmd, 5, true);
                        _is.read(fileData, 6, false);
                    }
                    kant::Int32 _ret = getLogData(application,serverName,nodeName,logFile,cmd,fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("fileData", fileData);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 6);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    vector<std::string> logFileList;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("logFileList", logFileList, logFileList);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(logFileList, _jsonPtr->value["logFileList"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(logFileList, 4, false);
                    }
                    kant::Int32 _ret = getLogFileList(application,serverName,nodeName,logFileList, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("logFileList", logFileList);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["logFileList"] = kant::JsonOutput::writeJson(logFileList);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(logFileList, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    kant::Int32 pid;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.get("pid", pid);
                        kantAttr.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(pid, _jsonPtr->value["pid"], true);
                        kant::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(pid, 4, true);
                        _is.read(fileData, 5, false);
                    }
                    kant::Int32 _ret = getNodeLoad(application,serverName,nodeName,pid,fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("fileData", fileData);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string version;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("name", name);
                        kantAttr.getByDefault("version", version, version);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(name, _jsonPtr->value["name"], true);
                        kant::JsonInput::readJson(version, _jsonPtr->value["version"], false);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(version, 2, false);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = getNodeVesion(name,version,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("version", version);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["version"] = kant::JsonOutput::writeJson(version);
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(version, 2);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    kant::PatchInfo tPatchInfo;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("tPatchInfo", tPatchInfo, tPatchInfo);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(tPatchInfo, _jsonPtr->value["tPatchInfo"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(tPatchInfo, 4, false);
                    }
                    kant::Int32 _ret = getPatchPercent(application,serverName,nodeName,tPatchInfo, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("tPatchInfo", tPatchInfo);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["tPatchInfo"] = kant::JsonOutput::writeJson(tPatchInfo);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tPatchInfo, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string profileName;
                    std::string profileTemplate;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("profileName", profileName);
                        kantAttr.getByDefault("profileTemplate", profileTemplate, profileTemplate);
                        kantAttr.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(profileName, _jsonPtr->value["profileName"], true);
                        kant::JsonInput::readJson(profileTemplate, _jsonPtr->value["profileTemplate"], false);
                        kant::JsonInput::readJson(resultDesc, _jsonPtr->value["resultDesc"], false);
                    }
                    else
                    {
                        _is.read(profileName, 1, true);
                        _is.read(profileTemplate, 2, false);
                        _is.read(resultDesc, 3, false);
                    }
                    kant::Int32 _ret = getProfileTemplate(profileName,profileTemplate,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("profileTemplate", profileTemplate);
                            kantAttr.put("resultDesc", resultDesc);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["profileTemplate"] = kant::JsonOutput::writeJson(profileTemplate);
                            _p->value["resultDesc"] = kant::JsonOutput::writeJson(resultDesc);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(profileTemplate, 2);
                            _os.write(resultDesc, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string profileTemplate;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("profileTemplate", profileTemplate, profileTemplate);
                        kantAttr.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(profileTemplate, _jsonPtr->value["profileTemplate"], false);
                        kant::JsonInput::readJson(resultDesc, _jsonPtr->value["resultDesc"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(profileTemplate, 4, false);
                        _is.read(resultDesc, 5, false);
                    }
                    kant::Int32 _ret = getServerProfileTemplate(application,serverName,nodeName,profileTemplate,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("profileTemplate", profileTemplate);
                            kantAttr.put("resultDesc", resultDesc);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["profileTemplate"] = kant::JsonOutput::writeJson(profileTemplate);
                            _p->value["resultDesc"] = kant::JsonOutput::writeJson(resultDesc);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(profileTemplate, 4);
                            _os.write(resultDesc, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    kant::ServerStateDesc state;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("state", state, state);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(state, _jsonPtr->value["state"], false);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(state, 4, false);
                        _is.read(result, 5, false);
                    }
                    kant::Int32 _ret = getServerState(application,serverName,nodeName,state,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("state", state);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["state"] = kant::JsonOutput::writeJson(state);
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(state, 4);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<kant::FrameworkServer> servers;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("servers", servers, servers);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(servers, _jsonPtr->value["servers"], false);
                    }
                    else
                    {
                        _is.read(servers, 1, false);
                    }
                    kant::Int32 _ret = getServers(servers, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("servers", servers);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["servers"] = kant::JsonOutput::writeJson(servers);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(servers, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string command;
                    vector<kant::TaskRsp> taskRsps;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("command", command);
                        kantAttr.getByDefault("taskRsps", taskRsps, taskRsps);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(command, _jsonPtr->value["command"], true);
                        kant::JsonInput::readJson(taskRsps, _jsonPtr->value["taskRsps"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(command, 3, true);
                        _is.read(taskRsps, 4, false);
                    }
                    kant::Int32 _ret = getTaskHistory(application,serverName,command,taskRsps, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("taskRsps", taskRsps);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["taskRsps"] = kant::JsonOutput::writeJson(taskRsps);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(taskRsps, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string taskNo;
                    kant::TaskRsp taskRsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("taskNo", taskNo);
                        kantAttr.getByDefault("taskRsp", taskRsp, taskRsp);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(taskNo, _jsonPtr->value["taskNo"], true);
                        kant::JsonInput::readJson(taskRsp, _jsonPtr->value["taskRsp"], false);
                    }
                    else
                    {
                        _is.read(taskNo, 1, true);
                        _is.read(taskRsp, 2, false);
                    }
                    kant::Int32 _ret = getTaskRsp(taskNo,taskRsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("taskRsp", taskRsp);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["taskRsp"] = kant::JsonOutput::writeJson(taskRsp);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(taskRsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 23:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string version;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("version", version, version);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(version, _jsonPtr->value["version"], false);
                    }
                    else
                    {
                        _is.read(version, 1, false);
                    }
                    kant::Int32 _ret = getVersion(version, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("version", version);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["version"] = kant::JsonOutput::writeJson(version);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(version, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 24:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = loadServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 25:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string command;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.get("command", command);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(command, _jsonPtr->value["command"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(command, 4, true);
                        _is.read(result, 5, false);
                    }
                    kant::Int32 _ret = notifyServer(application,serverName,nodeName,command,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 26:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("name", name);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(name, _jsonPtr->value["name"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(result, 2, false);
                    }
                    kant::Bool _ret = pingNode(name,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 27:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = restartServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 28:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string itemNo;
                    map<std::string, std::string> info;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("itemNo", itemNo);
                        kantAttr.get("info", info);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(itemNo, _jsonPtr->value["itemNo"], true);
                        kant::JsonInput::readJson(info, _jsonPtr->value["info"], true);
                    }
                    else
                    {
                        _is.read(itemNo, 1, true);
                        _is.read(info, 2, true);
                    }
                    kant::Int32 _ret = setTaskItemInfo(itemNo,info, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 29:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("name", name);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(name, _jsonPtr->value["name"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(result, 2, false);
                    }
                    kant::Int32 _ret = shutdownNode(name,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 30:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = startServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 31:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = stopServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 32:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string user;
                    std::string log;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.get("user", user);
                        kantAttr.getByDefault("log", log, log);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(user, _jsonPtr->value["user"], true);
                        kant::JsonInput::readJson(log, _jsonPtr->value["log"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(user, 4, true);
                        _is.read(log, 5, false);
                    }
                    kant::Int32 _ret = undeploy(application,serverName,nodeName,user,log, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("log", log);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["log"] = kant::JsonOutput::writeJson(log);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(log, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 33:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string patchId;
                    std::string user;
                    std::string patchType;
                    kant::Bool succ = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeName", nodeName);
                        kantAttr.get("patchId", patchId);
                        kantAttr.get("user", user);
                        kantAttr.get("patchType", patchType);
                        kantAttr.get("succ", succ);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], true);
                        kant::JsonInput::readJson(patchId, _jsonPtr->value["patchId"], true);
                        kant::JsonInput::readJson(user, _jsonPtr->value["user"], true);
                        kant::JsonInput::readJson(patchType, _jsonPtr->value["patchType"], true);
                        kant::JsonInput::readJson(succ, _jsonPtr->value["succ"], true);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(patchId, 4, true);
                        _is.read(user, 5, true);
                        _is.read(patchType, 6, true);
                        _is.read(succ, 7, true);
                    }
                    kant::Int32 _ret = updatePatchLog(application,serverName,nodeName,patchId,user,patchType,succ, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 34:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    vector<std::string> nodeList;
                    kant::Bool bActive = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("nodeList", nodeList);
                        kantAttr.get("bActive", bActive);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(nodeList, _jsonPtr->value["nodeList"], true);
                        kant::JsonInput::readJson(bActive, _jsonPtr->value["bActive"], true);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeList, 3, true);
                        _is.read(bActive, 4, true);
                    }
                    kant::Int32 _ret = updateServerFlowState(application,serverName,nodeList,bActive, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }
    };


}



#endif
