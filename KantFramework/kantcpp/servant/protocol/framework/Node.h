// **********************************************************************
// This file was generated by a KANT parser!
// KANT version KANT_VERSION.
// **********************************************************************

#ifndef __NODE_H_
#define __NODE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Kant.h"
#include "tup/KantJson.h"
using namespace std;
#include "NodeDescriptor.h"
#include "RegistryDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace kant
{

    /* callback of async proxy for client */
    class NodePrxCallback: public kant::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallback(){}
        virtual void callback_addFile(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_addFile() override incorrect."); }
        virtual void callback_addFile_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_addFile_exception() override incorrect."); }

        virtual void callback_delCache(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_delCache() override incorrect."); }
        virtual void callback_delCache_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_delCache_exception() override incorrect."); }

        virtual void callback_destroyServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_destroyServer() override incorrect."); }
        virtual void callback_destroyServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_destroyServer_exception() override incorrect."); }

        virtual void callback_forceDockerLogin(kant::Int32 ret,  const vector<std::string>& result)
        { throw std::runtime_error("callback_forceDockerLogin() override incorrect."); }
        virtual void callback_forceDockerLogin_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_forceDockerLogin_exception() override incorrect."); }

        virtual void callback_getLoad(const kant::LoadInfo& ret)
        { throw std::runtime_error("callback_getLoad() override incorrect."); }
        virtual void callback_getLoad_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getLoad_exception() override incorrect."); }

        virtual void callback_getLogData(kant::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getLogData() override incorrect."); }
        virtual void callback_getLogData_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getLogData_exception() override incorrect."); }

        virtual void callback_getLogFileList(kant::Int32 ret,  const vector<std::string>& logFileList)
        { throw std::runtime_error("callback_getLogFileList() override incorrect."); }
        virtual void callback_getLogFileList_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getLogFileList_exception() override incorrect."); }

        virtual void callback_getName(const std::string& ret)
        { throw std::runtime_error("callback_getName() override incorrect."); }
        virtual void callback_getName_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getName_exception() override incorrect."); }

        virtual void callback_getNodeLoad(kant::Int32 ret,  const std::string& fileData)
        { throw std::runtime_error("callback_getNodeLoad() override incorrect."); }
        virtual void callback_getNodeLoad_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getNodeLoad_exception() override incorrect."); }

        virtual void callback_getPatchPercent(kant::Int32 ret,  const kant::PatchInfo& tPatchInfo)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }

        virtual void callback_getServerPid(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_getServerPid() override incorrect."); }
        virtual void callback_getServerPid_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getServerPid_exception() override incorrect."); }

        virtual void callback_getSettingState(kant::ServerState ret,  const std::string& result)
        { throw std::runtime_error("callback_getSettingState() override incorrect."); }
        virtual void callback_getSettingState_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getSettingState_exception() override incorrect."); }

        virtual void callback_getState(kant::ServerState ret,  const std::string& result)
        { throw std::runtime_error("callback_getState() override incorrect."); }
        virtual void callback_getState_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getState_exception() override incorrect."); }

        virtual void callback_getStateInfo(kant::Int32 ret,  const kant::ServerStateInfo& info,  const std::string& result)
        { throw std::runtime_error("callback_getStateInfo() override incorrect."); }
        virtual void callback_getStateInfo_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getStateInfo_exception() override incorrect."); }

        virtual void callback_getUnusedShmKeys(kant::Int32 ret,  const vector<kant::Int32>& shm_keys)
        { throw std::runtime_error("callback_getUnusedShmKeys() override incorrect."); }
        virtual void callback_getUnusedShmKeys_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_getUnusedShmKeys_exception() override incorrect."); }

        virtual void callback_loadServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }

        virtual void callback_notifyServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }

        virtual void callback_patchPro(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_patchPro() override incorrect."); }
        virtual void callback_patchPro_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_patchPro_exception() override incorrect."); }

        virtual void callback_shutdown(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_shutdown() override incorrect."); }
        virtual void callback_shutdown_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_shutdown_exception() override incorrect."); }

        virtual void callback_startServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }

        virtual void callback_stopAllServers(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopAllServers() override incorrect."); }
        virtual void callback_stopAllServers_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_stopAllServers_exception() override incorrect."); }

        virtual void callback_stopServer(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }

        virtual void callback_synState(kant::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_synState() override incorrect."); }
        virtual void callback_synState_exception(kant::Int32 ret)
        { throw std::runtime_error("callback_synState_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw KT_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(kant::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLoad",
                "getLogData",
                "getLogFileList",
                "getName",
                "getNodeLoad",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };
            pair<string*, string*> r = equal_range(__Node_all, __Node_all+23, string(msg->request.sFuncName));
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_addFile_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_addFile(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_delCache_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_delCache(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_destroyServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_forceDockerLogin(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::LoadInfo _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getLoad(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogData_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getLogData(_ret, fileData);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<std::string> logFileList;
                    _is.read(logFileList, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getLogFileList(_ret, logFileList);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getName_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    std::string _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getName(_ret);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string fileData;
                    _is.read(fileData, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getNodeLoad(_ret, fileData);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    kant::PatchInfo tPatchInfo;
                    _is.read(tPatchInfo, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getPatchPercent(_ret, tPatchInfo);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerPid_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getServerPid(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getSettingState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::ServerState _ret = kant::Inactive;;
                    kant::Int32 eTemp0 = kant::Inactive;
                    _is.read(eTemp0, 0, true);
                    _ret = (kant::ServerState)eTemp0;

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getSettingState(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::ServerState _ret = kant::Inactive;;
                    kant::Int32 eTemp0 = kant::Inactive;
                    _is.read(eTemp0, 0, true);
                    _ret = (kant::ServerState)eTemp0;

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getState(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    kant::ServerStateInfo info;
                    _is.read(info, 3, true);
                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getStateInfo(_ret, info, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getUnusedShmKeys_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<kant::Int32> shm_keys;
                    _is.read(shm_keys, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_getUnusedShmKeys(_ret, shm_keys);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_loadServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_notifyServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_patchPro_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_patchPro(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_shutdown(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_startServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_stopAllServers(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_stopServer(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_synState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    kant::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_synState(_ret, result);

                    pCbtd->delResponseContext();

                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }

    };
    typedef std::shared_ptr<NodePrxCallback> NodePrxCallbackPtr;

    //callback of promise async proxy for client
    class NodePrxCallbackPromise: public kant::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallbackPromise(){}
    public:
        struct PromiseaddFile
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromiseaddFile > PromiseaddFilePtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromiseaddFilePtr > &promise)
        : _promise_addFile(promise)
        {}
        
        virtual void callback_addFile(const NodePrxCallbackPromise::PromiseaddFilePtr &ptr)
        {
            _promise_addFile.setValue(ptr);
        }
        virtual void callback_addFile_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:addFile_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_addFile.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromiseaddFilePtr > _promise_addFile;

    public:
        struct PromisedelCache
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisedelCache > PromisedelCachePtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisedelCachePtr > &promise)
        : _promise_delCache(promise)
        {}
        
        virtual void callback_delCache(const NodePrxCallbackPromise::PromisedelCachePtr &ptr)
        {
            _promise_delCache.setValue(ptr);
        }
        virtual void callback_delCache_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:delCache_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_delCache.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisedelCachePtr > _promise_delCache;

    public:
        struct PromisedestroyServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisedestroyServer > PromisedestroyServerPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > &promise)
        : _promise_destroyServer(promise)
        {}
        
        virtual void callback_destroyServer(const NodePrxCallbackPromise::PromisedestroyServerPtr &ptr)
        {
            _promise_destroyServer.setValue(ptr);
        }
        virtual void callback_destroyServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:destroyServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_destroyServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > _promise_destroyServer;

    public:
        struct PromiseforceDockerLogin
        {
        public:
            kant::Int32 _ret;
            vector<std::string> result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromiseforceDockerLogin > PromiseforceDockerLoginPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > &promise)
        : _promise_forceDockerLogin(promise)
        {}
        
        virtual void callback_forceDockerLogin(const NodePrxCallbackPromise::PromiseforceDockerLoginPtr &ptr)
        {
            _promise_forceDockerLogin.setValue(ptr);
        }
        virtual void callback_forceDockerLogin_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:forceDockerLogin_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_forceDockerLogin.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > _promise_forceDockerLogin;

    public:
        struct PromisegetLoad
        {
        public:
            kant::LoadInfo _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetLoad > PromisegetLoadPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetLoadPtr > &promise)
        : _promise_getLoad(promise)
        {}
        
        virtual void callback_getLoad(const NodePrxCallbackPromise::PromisegetLoadPtr &ptr)
        {
            _promise_getLoad.setValue(ptr);
        }
        virtual void callback_getLoad_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getLoad_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getLoad.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetLoadPtr > _promise_getLoad;

    public:
        struct PromisegetLogData
        {
        public:
            kant::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetLogData > PromisegetLogDataPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetLogDataPtr > &promise)
        : _promise_getLogData(promise)
        {}
        
        virtual void callback_getLogData(const NodePrxCallbackPromise::PromisegetLogDataPtr &ptr)
        {
            _promise_getLogData.setValue(ptr);
        }
        virtual void callback_getLogData_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogData_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getLogData.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetLogDataPtr > _promise_getLogData;

    public:
        struct PromisegetLogFileList
        {
        public:
            kant::Int32 _ret;
            vector<std::string> logFileList;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetLogFileList > PromisegetLogFileListPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetLogFileListPtr > &promise)
        : _promise_getLogFileList(promise)
        {}
        
        virtual void callback_getLogFileList(const NodePrxCallbackPromise::PromisegetLogFileListPtr &ptr)
        {
            _promise_getLogFileList.setValue(ptr);
        }
        virtual void callback_getLogFileList_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogFileList_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getLogFileList.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetLogFileListPtr > _promise_getLogFileList;

    public:
        struct PromisegetName
        {
        public:
            std::string _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetName > PromisegetNamePtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetNamePtr > &promise)
        : _promise_getName(promise)
        {}
        
        virtual void callback_getName(const NodePrxCallbackPromise::PromisegetNamePtr &ptr)
        {
            _promise_getName.setValue(ptr);
        }
        virtual void callback_getName_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getName_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getName.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetNamePtr > _promise_getName;

    public:
        struct PromisegetNodeLoad
        {
        public:
            kant::Int32 _ret;
            std::string fileData;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetNodeLoad > PromisegetNodeLoadPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetNodeLoadPtr > &promise)
        : _promise_getNodeLoad(promise)
        {}
        
        virtual void callback_getNodeLoad(const NodePrxCallbackPromise::PromisegetNodeLoadPtr &ptr)
        {
            _promise_getNodeLoad.setValue(ptr);
        }
        virtual void callback_getNodeLoad_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeLoad_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getNodeLoad.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetNodeLoadPtr > _promise_getNodeLoad;

    public:
        struct PromisegetPatchPercent
        {
        public:
            kant::Int32 _ret;
            kant::PatchInfo tPatchInfo;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const NodePrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getPatchPercent.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetServerPid
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetServerPid > PromisegetServerPidPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetServerPidPtr > &promise)
        : _promise_getServerPid(promise)
        {}
        
        virtual void callback_getServerPid(const NodePrxCallbackPromise::PromisegetServerPidPtr &ptr)
        {
            _promise_getServerPid.setValue(ptr);
        }
        virtual void callback_getServerPid_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerPid_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getServerPid.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetServerPidPtr > _promise_getServerPid;

    public:
        struct PromisegetSettingState
        {
        public:
            kant::ServerState _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetSettingState > PromisegetSettingStatePtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetSettingStatePtr > &promise)
        : _promise_getSettingState(promise)
        {}
        
        virtual void callback_getSettingState(const NodePrxCallbackPromise::PromisegetSettingStatePtr &ptr)
        {
            _promise_getSettingState.setValue(ptr);
        }
        virtual void callback_getSettingState_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getSettingState_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getSettingState.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetSettingStatePtr > _promise_getSettingState;

    public:
        struct PromisegetState
        {
        public:
            kant::ServerState _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetState > PromisegetStatePtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetStatePtr > &promise)
        : _promise_getState(promise)
        {}
        
        virtual void callback_getState(const NodePrxCallbackPromise::PromisegetStatePtr &ptr)
        {
            _promise_getState.setValue(ptr);
        }
        virtual void callback_getState_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getState_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getState.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetStatePtr > _promise_getState;

    public:
        struct PromisegetStateInfo
        {
        public:
            kant::Int32 _ret;
            kant::ServerStateInfo info;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetStateInfo > PromisegetStateInfoPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > &promise)
        : _promise_getStateInfo(promise)
        {}
        
        virtual void callback_getStateInfo(const NodePrxCallbackPromise::PromisegetStateInfoPtr &ptr)
        {
            _promise_getStateInfo.setValue(ptr);
        }
        virtual void callback_getStateInfo_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getStateInfo_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getStateInfo.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > _promise_getStateInfo;

    public:
        struct PromisegetUnusedShmKeys
        {
        public:
            kant::Int32 _ret;
            vector<kant::Int32> shm_keys;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisegetUnusedShmKeys > PromisegetUnusedShmKeysPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > &promise)
        : _promise_getUnusedShmKeys(promise)
        {}
        
        virtual void callback_getUnusedShmKeys(const NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr &ptr)
        {
            _promise_getUnusedShmKeys.setValue(ptr);
        }
        virtual void callback_getUnusedShmKeys_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:getUnusedShmKeys_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_getUnusedShmKeys.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > _promise_getUnusedShmKeys;

    public:
        struct PromiseloadServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const NodePrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_loadServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const NodePrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_notifyServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepatchPro
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisepatchPro > PromisepatchProPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisepatchProPtr > &promise)
        : _promise_patchPro(promise)
        {}
        
        virtual void callback_patchPro(const NodePrxCallbackPromise::PromisepatchProPtr &ptr)
        {
            _promise_patchPro.setValue(ptr);
        }
        virtual void callback_patchPro_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:patchPro_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_patchPro.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisepatchProPtr > _promise_patchPro;

    public:
        struct Promiseshutdown
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::Promiseshutdown > PromiseshutdownPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > &promise)
        : _promise_shutdown(promise)
        {}
        
        virtual void callback_shutdown(const NodePrxCallbackPromise::PromiseshutdownPtr &ptr)
        {
            _promise_shutdown.setValue(ptr);
        }
        virtual void callback_shutdown_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdown_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_shutdown.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > _promise_shutdown;

    public:
        struct PromisestartServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const NodePrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_startServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopAllServers
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisestopAllServers > PromisestopAllServersPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > &promise)
        : _promise_stopAllServers(promise)
        {}
        
        virtual void callback_stopAllServers(const NodePrxCallbackPromise::PromisestopAllServersPtr &ptr)
        {
            _promise_stopAllServers.setValue(ptr);
        }
        virtual void callback_stopAllServers_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:stopAllServers_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_stopAllServers.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > _promise_stopAllServers;

    public:
        struct PromisestopServer
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const NodePrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_stopServer.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        struct PromisesynState
        {
        public:
            kant::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef std::shared_ptr< NodePrxCallbackPromise::PromisesynState > PromisesynStatePtr;

        NodePrxCallbackPromise(const kant::Promise< NodePrxCallbackPromise::PromisesynStatePtr > &promise)
        : _promise_synState(promise)
        {}
        
        virtual void callback_synState(const NodePrxCallbackPromise::PromisesynStatePtr &ptr)
        {
            _promise_synState.setValue(ptr);
        }
        virtual void callback_synState_exception(kant::Int32 ret)
        {
            std::string str("");
            str += "Function:synState_exception|Ret:";
            str += KT_Common::tostr(ret);
            _promise_synState.setException(kant::copyException(str, ret));
        }

    protected:
        kant::Promise< NodePrxCallbackPromise::PromisesynStatePtr > _promise_synState;

    public:
        virtual int onDispatch(kant::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLoad",
                "getLogData",
                "getLogFileList",
                "getName",
                "getNodeLoad",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+23, string(msg->request.sFuncName));
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_addFile_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromiseaddFilePtr ptr = std::make_shared<NodePrxCallbackPromise::PromiseaddFile>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_addFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_addFile(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_delCache_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisedelCachePtr ptr = std::make_shared<NodePrxCallbackPromise::PromisedelCache>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_delCache(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisedestroyServerPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisedestroyServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_destroyServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromiseforceDockerLoginPtr ptr = std::make_shared<NodePrxCallbackPromise::PromiseforceDockerLogin>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_forceDockerLogin(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetLoadPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetLoad>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getLoad(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogData_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetLogDataPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetLogData>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getLogData(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetLogFileListPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetLogFileList>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->logFileList, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getLogFileList(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getName_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetNamePtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetName>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getName_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getName_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getName(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetNodeLoadPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetNodeLoad>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->fileData, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getNodeLoad(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetPatchPercentPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetPatchPercent>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tPatchInfo, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getPatchPercent(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerPid_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetServerPidPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetServerPid>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerPid_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerPid_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getServerPid(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getSettingState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetSettingStatePtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetSettingState>();

                    try
                    {
                        ptr->_ret  = kant::Inactive;;
                        kant::Int32 eTemp0 = kant::Inactive;
                        _is.read(eTemp0, 0, true);
                        ptr->_ret = (kant::ServerState)eTemp0;

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getSettingState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getSettingState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getSettingState(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetStatePtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetState>();

                    try
                    {
                        ptr->_ret  = kant::Inactive;;
                        kant::Int32 eTemp0 = kant::Inactive;
                        _is.read(eTemp0, 0, true);
                        ptr->_ret = (kant::ServerState)eTemp0;

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getState(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetStateInfoPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetStateInfo>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->info, 3, true);
                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getStateInfo(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getUnusedShmKeys_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisegetUnusedShmKeys>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->shm_keys, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getUnusedShmKeys_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getUnusedShmKeys_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_getUnusedShmKeys(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromiseloadServerPtr ptr = std::make_shared<NodePrxCallbackPromise::PromiseloadServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_loadServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisenotifyServerPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisenotifyServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_notifyServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_patchPro_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisepatchProPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisepatchPro>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_patchPro(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromiseshutdownPtr ptr = std::make_shared<NodePrxCallbackPromise::Promiseshutdown>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_shutdown(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisestartServerPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisestartServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_startServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisestopAllServersPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisestopAllServers>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopAllServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopAllServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_stopAllServers(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisestopServerPtr ptr = std::make_shared<NodePrxCallbackPromise::PromisestopServer>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_stopServer(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_synState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);

                    NodePrxCallbackPromise::PromisesynStatePtr ptr = std::make_shared<NodePrxCallbackPromise::PromisesynState>();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_synState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_synState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response->context;

                    callback_synState(ptr);

                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }

    };
    typedef std::shared_ptr<NodePrxCallbackPromise> NodePrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class NodeCoroPrxCallback: public NodePrxCallback
    {
    public:
        virtual ~NodeCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(kant::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLoad",
                "getLogData",
                "getLogFileList",
                "getName",
                "getNodeLoad",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+23, string(msg->request.sFuncName));
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_addFile_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_addFile(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addFile_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_delCache_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_delCache(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_destroyServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response->context);

                        callback_forceDockerLogin(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::LoadInfo _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_getLoad(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogData_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 5, true);
                        setResponseContext(msg->response->context);

                        callback_getLogData(_ret, fileData);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<std::string> logFileList;
                        _is.read(logFileList, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getLogFileList(_ret, logFileList);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getName_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        std::string _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_getName(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getName_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getName_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string fileData;
                        _is.read(fileData, 4, true);
                        setResponseContext(msg->response->context);

                        callback_getNodeLoad(_ret, fileData);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        kant::PatchInfo tPatchInfo;
                        _is.read(tPatchInfo, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getPatchPercent(_ret, tPatchInfo);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getServerPid_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getServerPid(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerPid_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerPid_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getSettingState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::ServerState _ret = kant::Inactive;;
                        kant::Int32 eTemp0 = kant::Inactive;
                        _is.read(eTemp0, 0, true);
                        _ret = (kant::ServerState)eTemp0;

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getSettingState(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getSettingState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getSettingState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::ServerState _ret = kant::Inactive;;
                        kant::Int32 eTemp0 = kant::Inactive;
                        _is.read(eTemp0, 0, true);
                        _ret = (kant::ServerState)eTemp0;

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_getState(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        kant::ServerStateInfo info;
                        _is.read(info, 3, true);
                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_getStateInfo(_ret, info, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_getUnusedShmKeys_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<kant::Int32> shm_keys;
                        _is.read(shm_keys, 2, true);
                        setResponseContext(msg->response->context);

                        callback_getUnusedShmKeys(_ret, shm_keys);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getUnusedShmKeys_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getUnusedShmKeys_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_loadServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response->context);

                        callback_notifyServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_patchPro_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response->context);

                        callback_patchPro(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response->context);

                        callback_shutdown(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_startServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response->context);

                        callback_stopAllServers(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopAllServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopAllServers_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_stopServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response->iRet != kant::KANTSERVERSUCCESS)
                    {
                        callback_synState_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    kant::KantInputStream<kant::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        kant::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response->context);

                        callback_synState(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_synState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_synState_exception(kant::KANTCLIENTDECODEERR);

                        return kant::KANTCLIENTDECODEERR;
                    }

                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef std::shared_ptr<NodeCoroPrxCallback> NodeCoroPrxCallbackPtr;

    /* proxy for client */
    class NodeProxy : public kant::ServantProxy
    {
    public:
        typedef map<string, string> KANT_CONTEXT;
        NodeProxy(Communicator* pCommunicator, const string& name, const string& setName)
                : ServantProxy(pCommunicator, name, setName) {}

        kant::Int32 addFile(const std::string & application,const std::string & serverName,const std::string & file,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"addFile", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_addFile(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &file,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"addFile", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromiseaddFilePtr > promise_async_addFile(const std::string &application,const std::string &serverName,const std::string &file,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromiseaddFilePtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"addFile", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_addFile(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &file,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"addFile", _os, context, _mStatus, callback, true);
        }

        kant::Int32 delCache(const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"delCache", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_delCache(NodePrxCallbackPtr callback,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"delCache", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisedelCachePtr > promise_async_delCache(const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisedelCachePtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"delCache", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_delCache(NodeCoroPrxCallbackPtr callback,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"delCache", _os, context, _mStatus, callback, true);
        }

        kant::Int32 destroyServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"destroyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_destroyServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"destroyServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisedestroyServerPtr > promise_async_destroyServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"destroyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_destroyServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"destroyServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 forceDockerLogin(vector<std::string> &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_forceDockerLogin(NodePrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > promise_async_forceDockerLogin(const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromiseforceDockerLoginPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_forceDockerLogin(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"forceDockerLogin", _os, context, _mStatus, callback, true);
        }

        kant::LoadInfo getLoad(const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getLoad", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::LoadInfo _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_getLoad(NodePrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLoad", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetLoadPtr > promise_async_getLoad(const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetLoadPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLoad", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLoad(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLoad", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & logFile,const std::string & cmd,std::string &fileData,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            _os.write(fileData, 5);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getLogData", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 5, true);
            return _ret;
        }

        void async_getLogData(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogData", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetLogDataPtr > promise_async_getLogData(const std::string &application,const std::string &serverName,const std::string &logFile,const std::string &cmd,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetLogDataPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogData", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogData(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &logFile,const std::string &cmd,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFile, 3);
            _os.write(cmd, 4);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogData", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getLogFileList(const std::string & application,const std::string & serverName,vector<std::string> &logFileList,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(logFileList, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(logFileList, 3, true);
            return _ret;
        }

        void async_getLogFileList(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetLogFileListPtr > promise_async_getLogFileList(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetLogFileListPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogFileList(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getLogFileList", _os, context, _mStatus, callback, true);
        }

        std::string getName(const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getName", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            std::string _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_getName(NodePrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getName", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetNamePtr > promise_async_getName(const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetNamePtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getName", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getName(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getName", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getNodeLoad(const std::string & application,const std::string & serverName,kant::Int32 pid,std::string &fileData,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            _os.write(fileData, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(fileData, 4, true);
            return _ret;
        }

        void async_getNodeLoad(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,kant::Int32 pid,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetNodeLoadPtr > promise_async_getNodeLoad(const std::string &application,const std::string &serverName,kant::Int32 pid,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetNodeLoadPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeLoad(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,kant::Int32 pid,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(pid, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getNodeLoad", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getPatchPercent(const std::string & application,const std::string & serverName,kant::PatchInfo &tPatchInfo,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(tPatchInfo, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tPatchInfo, 3, true);
            return _ret;
        }

        void async_getPatchPercent(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getPatchPercent", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getServerPid(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getServerPid", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getServerPid(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerPid", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetServerPidPtr > promise_async_getServerPid(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetServerPidPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerPid", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerPid(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getServerPid", _os, context, _mStatus, callback, true);
        }

        kant::ServerState getSettingState(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getSettingState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::ServerState _ret = kant::Inactive;;
            kant::Int32 eTemp0 = kant::Inactive;
            _is.read(eTemp0, 0, true);
            _ret = (kant::ServerState)eTemp0;
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getSettingState(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getSettingState", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetSettingStatePtr > promise_async_getSettingState(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetSettingStatePtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getSettingState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getSettingState(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getSettingState", _os, context, _mStatus, callback, true);
        }

        kant::ServerState getState(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::ServerState _ret = kant::Inactive;;
            kant::Int32 eTemp0 = kant::Inactive;
            _is.read(eTemp0, 0, true);
            _ret = (kant::ServerState)eTemp0;
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getState(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getState", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetStatePtr > promise_async_getState(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetStatePtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getState(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getState", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getStateInfo(const std::string & application,const std::string & serverName,kant::ServerStateInfo &info,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(info, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getStateInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(info, 3, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_getStateInfo(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getStateInfo", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetStateInfoPtr > promise_async_getStateInfo(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getStateInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getStateInfo(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getStateInfo", _os, context, _mStatus, callback, true);
        }

        kant::Int32 getUnusedShmKeys(kant::Int32 count,vector<kant::Int32> &shm_keys,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(count, 1);
            _os.write(shm_keys, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"getUnusedShmKeys", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(shm_keys, 2, true);
            return _ret;
        }

        void async_getUnusedShmKeys(NodePrxCallbackPtr callback,kant::Int32 count,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(count, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getUnusedShmKeys", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > promise_async_getUnusedShmKeys(kant::Int32 count,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(count, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getUnusedShmKeys", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getUnusedShmKeys(NodeCoroPrxCallbackPtr callback,kant::Int32 count,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(count, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"getUnusedShmKeys", _os, context, _mStatus, callback, true);
        }

        kant::Int32 loadServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"loadServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_loadServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"loadServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"loadServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"loadServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & command,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            _os.write(result, 4);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_notifyServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"notifyServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 patchPro(const kant::PatchRequest & req,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(result, 2);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"patchPro", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_patchPro(NodePrxCallbackPtr callback,const kant::PatchRequest &req,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"patchPro", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisepatchProPtr > promise_async_patchPro(const kant::PatchRequest &req,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisepatchProPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"patchPro", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_patchPro(NodeCoroPrxCallbackPtr callback,const kant::PatchRequest &req,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"patchPro", _os, context, _mStatus, callback, true);
        }

        kant::Int32 shutdown(std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"shutdown", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_shutdown(NodePrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"shutdown", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromiseshutdownPtr > promise_async_shutdown(const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"shutdown", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdown(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"shutdown", _os, context, _mStatus, callback, true);
        }

        kant::Int32 startServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"startServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_startServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"startServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisestartServerPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"startServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"startServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 stopAllServers(std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(result, 1);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"stopAllServers", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_stopAllServers(NodePrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopAllServers", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisestopAllServersPtr > promise_async_stopAllServers(const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopAllServers", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopAllServers(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopAllServers", _os, context, _mStatus, callback, true);
        }

        kant::Int32 stopServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"stopServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_stopServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopServer", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisestopServerPtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"stopServer", _os, context, _mStatus, callback, true);
        }

        kant::Int32 synState(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = KANT_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            std::map<string, string> _mStatus;
            shared_ptr<kant::ResponsePacket> rep = kant_invoke(kant::KANTNORMAL,"synState", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            kant::KantInputStream<kant::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            kant::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_synState(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"synState", _os, context, _mStatus, callback);
        }
        
        kant::Future< NodePrxCallbackPromise::PromisesynStatePtr > promise_async_synState(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            kant::Promise< NodePrxCallbackPromise::PromisesynStatePtr > promise;
            NodePrxCallbackPromisePtr callback = std::make_shared<NodePrxCallbackPromise>(promise);

            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"synState", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_synState(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = KANT_CONTEXT())
        {
            kant::KantOutputStream<kant::BufferWriterVector> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            kant_invoke_async(kant::KANTNORMAL,"synState", _os, context, _mStatus, callback, true);
        }

        NodeProxy* kant_hash(int64_t key)
        {
            return (NodeProxy*)ServantProxy::kant_hash(key);
        }

        NodeProxy* kant_consistent_hash(int64_t key)
        {
            return (NodeProxy*)ServantProxy::kant_consistent_hash(key);
        }

        NodeProxy* kant_open_trace(bool traceParam = false)
        {
            return (NodeProxy*)ServantProxy::kant_open_trace(traceParam);
        }

        NodeProxy* kant_set_timeout(int msecond)
        {
            return (NodeProxy*)ServantProxy::kant_set_timeout(msecond);
        }

        static const char* kant_prxname() { return "NodeProxy"; }
    };
    typedef std::shared_ptr<NodeProxy> NodePrx;

    /* servant for server */
    class Node : public kant::Servant
    {
    public:
        virtual ~Node(){}
        virtual kant::Int32 addFile(const std::string & application,const std::string & serverName,const std::string & file,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_addFile(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 delCache(const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_delCache(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 destroyServer(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_destroyServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 forceDockerLogin(vector<std::string> &result,kant::KantCurrentPtr current) = 0;
        static void async_response_forceDockerLogin(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<std::string> &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::LoadInfo getLoad(kant::KantCurrentPtr current) = 0;
        static void async_response_getLoad(kant::KantCurrentPtr current, const kant::LoadInfo &_ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getLogData(const std::string & application,const std::string & serverName,const std::string & logFile,const std::string & cmd,std::string &fileData,kant::KantCurrentPtr current) = 0;
        static void async_response_getLogData(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &fileData)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 5);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getLogFileList(const std::string & application,const std::string & serverName,vector<std::string> &logFileList,kant::KantCurrentPtr current) = 0;
        static void async_response_getLogFileList(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<std::string> &logFileList)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("logFileList", logFileList);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["logFileList"] = kant::JsonOutput::writeJson(logFileList);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(logFileList, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual std::string getName(kant::KantCurrentPtr current) = 0;
        static void async_response_getName(kant::KantCurrentPtr current, const std::string &_ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getNodeLoad(const std::string & application,const std::string & serverName,kant::Int32 pid,std::string &fileData,kant::KantCurrentPtr current) = 0;
        static void async_response_getNodeLoad(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &fileData)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("fileData", fileData);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(fileData, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getPatchPercent(const std::string & application,const std::string & serverName,kant::PatchInfo &tPatchInfo,kant::KantCurrentPtr current) = 0;
        static void async_response_getPatchPercent(kant::KantCurrentPtr current, kant::Int32 _ret, const kant::PatchInfo &tPatchInfo)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("tPatchInfo", tPatchInfo);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["tPatchInfo"] = kant::JsonOutput::writeJson(tPatchInfo);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getServerPid(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getServerPid(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::ServerState getSettingState(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getSettingState(kant::KantCurrentPtr current, kant::ServerState _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", (kant::Int32)_ret);
                kantAttr.put("kant_ret", (kant::Int32)_ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write((kant::Int32)_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::ServerState getState(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getState(kant::KantCurrentPtr current, kant::ServerState _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", (kant::Int32)_ret);
                kantAttr.put("kant_ret", (kant::Int32)_ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write((kant::Int32)_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getStateInfo(const std::string & application,const std::string & serverName,kant::ServerStateInfo &info,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_getStateInfo(kant::KantCurrentPtr current, kant::Int32 _ret, const kant::ServerStateInfo &info, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("info", info);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["info"] = kant::JsonOutput::writeJson(info);
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(info, 3);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 getUnusedShmKeys(kant::Int32 count,vector<kant::Int32> &shm_keys,kant::KantCurrentPtr current) = 0;
        static void async_response_getUnusedShmKeys(kant::KantCurrentPtr current, kant::Int32 _ret, const vector<kant::Int32> &shm_keys)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("shm_keys", shm_keys);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["shm_keys"] = kant::JsonOutput::writeJson(shm_keys);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(shm_keys, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 loadServer(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_loadServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & command,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_notifyServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 patchPro(const kant::PatchRequest & req,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_patchPro(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 shutdown(std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_shutdown(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 startServer(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_startServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 stopAllServers(std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_stopAllServers(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 stopServer(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_stopServer(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual kant::Int32 synState(const std::string & application,const std::string & serverName,std::string &result,kant::KantCurrentPtr current) = 0;
        static void async_response_synState(kant::KantCurrentPtr current, kant::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                kantAttr.setVersion(current->getRequestVersion());
                kantAttr.put("", _ret);
                kantAttr.put("kant_ret", _ret);
                kantAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                kantAttr.encode(sTupResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                _p->value["result"] = kant::JsonOutput::writeJson(result);
                _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                kant::KT_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(kant::KANTSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                kant::KantOutputStream<kant::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(kant::KANTSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(kant::KantCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __kant__Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLoad",
                "getLogData",
                "getLogFileList",
                "getName",
                "getNodeLoad",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };

            pair<string*, string*> r = equal_range(__kant__Node_all, __kant__Node_all+23, _current->getFuncName());
            if(r.first == r.second) return kant::KANTSERVERNOFUNCERR;
            switch(r.first - __kant__Node_all)
            {
                case 0:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string file;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("file", file);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(file, _jsonPtr->value["file"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(file, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = addFile(application,serverName,file,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 1:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sFullCacheName;
                    std::string sBackupPath;
                    std::string sKey;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("sFullCacheName", sFullCacheName);
                        kantAttr.get("sBackupPath", sBackupPath);
                        kantAttr.get("sKey", sKey);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(sFullCacheName, _jsonPtr->value["sFullCacheName"], true);
                        kant::JsonInput::readJson(sBackupPath, _jsonPtr->value["sBackupPath"], true);
                        kant::JsonInput::readJson(sKey, _jsonPtr->value["sKey"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(sFullCacheName, 1, true);
                        _is.read(sBackupPath, 2, true);
                        _is.read(sKey, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = delCache(sFullCacheName,sBackupPath,sKey,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 2:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = destroyServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 3:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<std::string> result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    kant::Int32 _ret = forceDockerLogin(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 4:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                    }
                    else
                    {
                    }
                    kant::LoadInfo _ret = getLoad(_current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 5:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string logFile;
                    std::string cmd;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("logFile", logFile);
                        kantAttr.get("cmd", cmd);
                        kantAttr.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(logFile, _jsonPtr->value["logFile"], true);
                        kant::JsonInput::readJson(cmd, _jsonPtr->value["cmd"], true);
                        kant::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(logFile, 3, true);
                        _is.read(cmd, 4, true);
                        _is.read(fileData, 5, false);
                    }
                    kant::Int32 _ret = getLogData(application,serverName,logFile,cmd,fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("fileData", fileData);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 6:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    vector<std::string> logFileList;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("logFileList", logFileList, logFileList);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(logFileList, _jsonPtr->value["logFileList"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(logFileList, 3, false);
                    }
                    kant::Int32 _ret = getLogFileList(application,serverName,logFileList, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("logFileList", logFileList);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["logFileList"] = kant::JsonOutput::writeJson(logFileList);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(logFileList, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 7:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                    }
                    else
                    {
                    }
                    std::string _ret = getName(_current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 8:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    kant::Int32 pid;
                    std::string fileData;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("pid", pid);
                        kantAttr.getByDefault("fileData", fileData, fileData);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(pid, _jsonPtr->value["pid"], true);
                        kant::JsonInput::readJson(fileData, _jsonPtr->value["fileData"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(pid, 3, true);
                        _is.read(fileData, 4, false);
                    }
                    kant::Int32 _ret = getNodeLoad(application,serverName,pid,fileData, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("fileData", fileData);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["fileData"] = kant::JsonOutput::writeJson(fileData);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(fileData, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 9:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    kant::PatchInfo tPatchInfo;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("tPatchInfo", tPatchInfo, tPatchInfo);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(tPatchInfo, _jsonPtr->value["tPatchInfo"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(tPatchInfo, 3, false);
                    }
                    kant::Int32 _ret = getPatchPercent(application,serverName,tPatchInfo, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("tPatchInfo", tPatchInfo);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["tPatchInfo"] = kant::JsonOutput::writeJson(tPatchInfo);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tPatchInfo, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 10:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = getServerPid(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 11:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::ServerState _ret = getSettingState(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", (kant::Int32)_ret);
                            kantAttr.put("kant_ret", (kant::Int32)_ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write((kant::Int32)_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 12:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::ServerState _ret = getState(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", (kant::Int32)_ret);
                            kantAttr.put("kant_ret", (kant::Int32)_ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write((kant::Int32)_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 13:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    kant::ServerStateInfo info;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("info", info, info);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(info, _jsonPtr->value["info"], false);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(info, 3, false);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = getStateInfo(application,serverName,info,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("info", info);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["info"] = kant::JsonOutput::writeJson(info);
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(info, 3);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 14:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    kant::Int32 count;
                    vector<kant::Int32> shm_keys;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("count", count);
                        kantAttr.getByDefault("shm_keys", shm_keys, shm_keys);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(count, _jsonPtr->value["count"], true);
                        kant::JsonInput::readJson(shm_keys, _jsonPtr->value["shm_keys"], false);
                    }
                    else
                    {
                        _is.read(count, 1, true);
                        _is.read(shm_keys, 2, false);
                    }
                    kant::Int32 _ret = getUnusedShmKeys(count,shm_keys, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("shm_keys", shm_keys);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["shm_keys"] = kant::JsonOutput::writeJson(shm_keys);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(shm_keys, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 15:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = loadServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 16:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string command;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.get("command", command);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(command, _jsonPtr->value["command"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(command, 3, true);
                        _is.read(result, 4, false);
                    }
                    kant::Int32 _ret = notifyServer(application,serverName,command,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 17:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    kant::PatchRequest req;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("req", req);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(result, 2, false);
                    }
                    kant::Int32 _ret = patchPro(req,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 18:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    kant::Int32 _ret = shutdown(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 19:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = startServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 20:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    kant::Int32 _ret = stopAllServers(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 21:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = stopServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
                case 22:
                {
                    kant::KantInputStream<kant::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                        kantAttr.setVersion(_current->getRequestVersion());
                        kantAttr.decode(_current->getRequestBuffer());
                        kantAttr.get("application", application);
                        kantAttr.get("serverName", serverName);
                        kantAttr.getByDefault("result", result, result);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        kant::JsonValueObjPtr _jsonPtr = std::dynamic_pointer_cast<kant::JsonValueObj>(kant::KT_Json::getValue(_current->getRequestBuffer()));
                        kant::JsonInput::readJson(application, _jsonPtr->value["application"], true);
                        kant::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], true);
                        kant::JsonInput::readJson(result, _jsonPtr->value["result"], false);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    kant::Int32 _ret = synState(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<kant::BufferWriterVector, kant::BufferReader>  kantAttr;
                            kantAttr.setVersion(_current->getRequestVersion());
                            kantAttr.put("", _ret);
                            kantAttr.put("kant_ret", _ret);
                            kantAttr.put("result", result);
                            kantAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            kant::JsonValueObjPtr _p = std::make_shared< kant::JsonValueObj>();
                            _p->value["result"] = kant::JsonOutput::writeJson(result);
                            _p->value["kant_ret"] = kant::JsonOutput::writeJson(_ret);
                            kant::KT_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            kant::KantOutputStream<kant::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return kant::KANTSERVERSUCCESS;

                }
            }
            return kant::KANTSERVERNOFUNCERR;
        }
    };


}



#endif
