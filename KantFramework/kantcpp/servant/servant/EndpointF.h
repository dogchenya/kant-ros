// **********************************************************************
// This file was generated by a KANT parser!
// KANT version KANT_VERSION.
// **********************************************************************

#ifndef __ENDPOINTF_H_
#define __ENDPOINTF_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Kant.h"
#include "tup/KantJson.h"
using namespace std;


namespace kant
{
    struct EndpointF : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.EndpointF";
        }
        static string MD5()
        {
            return "c469126b99a4bd0cf392113e14a9d150";
        }
        EndpointF()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            host = "";
            port = 0;
            timeout = 0;
            istcp = 0;
            grid = 0;
            groupworkid = 0;
            grouprealid = 0;
            setId = "";
            qos = 0;
            bakFlag = 0;
            weight = 0;
            weightType = 0;
            authType = 0;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(host, 0);
            _os.write(port, 1);
            _os.write(timeout, 2);
            _os.write(istcp, 3);
            _os.write(grid, 4);
            if (groupworkid != 0)
            {
                _os.write(groupworkid, 5);
            }
            if (grouprealid != 0)
            {
                _os.write(grouprealid, 6);
            }
            if (setId != "")
            {
                _os.write(setId, 7);
            }
            if (qos != 0)
            {
                _os.write(qos, 8);
            }
            if (bakFlag != 0)
            {
                _os.write(bakFlag, 9);
            }
            if (weight != 0)
            {
                _os.write(weight, 11);
            }
            if (weightType != 0)
            {
                _os.write(weightType, 12);
            }
            if (authType != 0)
            {
                _os.write(authType, 13);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(host, 0, true);
            _is.read(port, 1, true);
            _is.read(timeout, 2, true);
            _is.read(istcp, 3, true);
            _is.read(grid, 4, true);
            _is.read(groupworkid, 5, false);
            _is.read(grouprealid, 6, false);
            _is.read(setId, 7, false);
            _is.read(qos, 8, false);
            _is.read(bakFlag, 9, false);
            _is.read(weight, 11, false);
            _is.read(weightType, 12, false);
            _is.read(authType, 13, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["host"] = kant::JsonOutput::writeJson(host);
            p->value["port"] = kant::JsonOutput::writeJson(port);
            p->value["timeout"] = kant::JsonOutput::writeJson(timeout);
            p->value["istcp"] = kant::JsonOutput::writeJson(istcp);
            p->value["grid"] = kant::JsonOutput::writeJson(grid);
            p->value["groupworkid"] = kant::JsonOutput::writeJson(groupworkid);
            p->value["grouprealid"] = kant::JsonOutput::writeJson(grouprealid);
            p->value["setId"] = kant::JsonOutput::writeJson(setId);
            p->value["qos"] = kant::JsonOutput::writeJson(qos);
            p->value["bakFlag"] = kant::JsonOutput::writeJson(bakFlag);
            p->value["weight"] = kant::JsonOutput::writeJson(weight);
            p->value["weightType"] = kant::JsonOutput::writeJson(weightType);
            p->value["authType"] = kant::JsonOutput::writeJson(authType);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(host,pObj->value["host"], true);
            kant::JsonInput::readJson(port,pObj->value["port"], true);
            kant::JsonInput::readJson(timeout,pObj->value["timeout"], true);
            kant::JsonInput::readJson(istcp,pObj->value["istcp"], true);
            kant::JsonInput::readJson(grid,pObj->value["grid"], true);
            kant::JsonInput::readJson(groupworkid,pObj->value["groupworkid"], false);
            kant::JsonInput::readJson(grouprealid,pObj->value["grouprealid"], false);
            kant::JsonInput::readJson(setId,pObj->value["setId"], false);
            kant::JsonInput::readJson(qos,pObj->value["qos"], false);
            kant::JsonInput::readJson(bakFlag,pObj->value["bakFlag"], false);
            kant::JsonInput::readJson(weight,pObj->value["weight"], false);
            kant::JsonInput::readJson(weightType,pObj->value["weightType"], false);
            kant::JsonInput::readJson(authType,pObj->value["authType"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(host,"host");
            _ds.display(port,"port");
            _ds.display(timeout,"timeout");
            _ds.display(istcp,"istcp");
            _ds.display(grid,"grid");
            _ds.display(groupworkid,"groupworkid");
            _ds.display(grouprealid,"grouprealid");
            _ds.display(setId,"setId");
            _ds.display(qos,"qos");
            _ds.display(bakFlag,"bakFlag");
            _ds.display(weight,"weight");
            _ds.display(weightType,"weightType");
            _ds.display(authType,"authType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(host, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(timeout, true);
            _ds.displaySimple(istcp, true);
            _ds.displaySimple(grid, true);
            _ds.displaySimple(groupworkid, true);
            _ds.displaySimple(grouprealid, true);
            _ds.displaySimple(setId, true);
            _ds.displaySimple(qos, true);
            _ds.displaySimple(bakFlag, true);
            _ds.displaySimple(weight, true);
            _ds.displaySimple(weightType, true);
            _ds.displaySimple(authType, false);
            return _os;
        }
    public:
        std::string host;
        kant::Int32 port;
        kant::Int32 timeout;
        kant::Int32 istcp;
        kant::Int32 grid;
        kant::Int32 groupworkid;
        kant::Int32 grouprealid;
        std::string setId;
        kant::Int32 qos;
        kant::Int32 bakFlag;
        kant::Int32 weight;
        kant::Int32 weightType;
        kant::Int32 authType;
    };
    inline bool operator==(const EndpointF&l, const EndpointF&r)
    {
        return l.host == r.host && l.port == r.port && l.timeout == r.timeout && l.istcp == r.istcp && l.grid == r.grid && l.groupworkid == r.groupworkid && l.grouprealid == r.grouprealid && l.setId == r.setId && l.qos == r.qos && l.bakFlag == r.bakFlag && l.weight == r.weight && l.weightType == r.weightType && l.authType == r.authType;
    }
    inline bool operator!=(const EndpointF&l, const EndpointF&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const EndpointF&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,EndpointF&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }
    inline bool operator<(const EndpointF&l, const EndpointF&r)
    {
        if(l.host != r.host)  return (l.host < r.host);
        if(l.port != r.port)  return (l.port < r.port);
        if(l.timeout != r.timeout)  return (l.timeout < r.timeout);
        if(l.istcp != r.istcp)  return (l.istcp < r.istcp);
        if(l.grid != r.grid)  return (l.grid < r.grid);
        if(l.qos != r.qos)  return (l.qos < r.qos);
        if(l.weight != r.weight)  return (l.weight < r.weight);
        if(l.weightType != r.weightType)  return (l.weightType < r.weightType);
        if(l.authType != r.authType)  return (l.authType < r.authType);
        return false;
    }
    inline bool operator<=(const EndpointF&l, const EndpointF&r)
    {
        return !(r < l);
    }
    inline bool operator>(const EndpointF&l, const EndpointF&r)
    {
        return r < l;
    }
    inline bool operator>=(const EndpointF&l, const EndpointF&r)
    {
        return !(l < r);
    }


}



#endif
