// **********************************************************************
// This file was generated by a KANT parser!
// KANT version KANT_VERSION.
// **********************************************************************

#ifndef __REGISTRYDESCRIPTOR_H_
#define __REGISTRYDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Kant.h"
#include "tup/KantJson.h"
using namespace std;
#include "EndpointF.h"


namespace kant
{
    struct AdapterDescriptor : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.AdapterDescriptor";
        }
        static string MD5()
        {
            return "ffe9e5152d8c670c54833b421063dc05";
        }
        AdapterDescriptor()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            adapterName = "";
            threadNum = "";
            endpoint = "";
            maxConnections = 0;
            allowIp = "";
            servant = "";
            queuecap = 0;
            queuetimeout = 0;
            grid = 0;
            protocol = "";
            handlegroup = "";
            shmkey = 0;
            shmcap = 0;
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(adapterName, 0);
            _os.write(threadNum, 1);
            _os.write(endpoint, 2);
            _os.write(maxConnections, 3);
            _os.write(allowIp, 4);
            _os.write(servant, 5);
            _os.write(queuecap, 6);
            _os.write(queuetimeout, 7);
            _os.write(grid, 8);
            if (protocol != "")
            {
                _os.write(protocol, 9);
            }
            if (handlegroup != "")
            {
                _os.write(handlegroup, 10);
            }
            if (shmkey != 0)
            {
                _os.write(shmkey, 11);
            }
            if (shmcap != 0)
            {
                _os.write(shmcap, 12);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(adapterName, 0, true);
            _is.read(threadNum, 1, true);
            _is.read(endpoint, 2, true);
            _is.read(maxConnections, 3, true);
            _is.read(allowIp, 4, true);
            _is.read(servant, 5, true);
            _is.read(queuecap, 6, true);
            _is.read(queuetimeout, 7, true);
            _is.read(grid, 8, true);
            _is.read(protocol, 9, false);
            _is.read(handlegroup, 10, false);
            _is.read(shmkey, 11, false);
            _is.read(shmcap, 12, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["adapterName"] = kant::JsonOutput::writeJson(adapterName);
            p->value["threadNum"] = kant::JsonOutput::writeJson(threadNum);
            p->value["endpoint"] = kant::JsonOutput::writeJson(endpoint);
            p->value["maxConnections"] = kant::JsonOutput::writeJson(maxConnections);
            p->value["allowIp"] = kant::JsonOutput::writeJson(allowIp);
            p->value["servant"] = kant::JsonOutput::writeJson(servant);
            p->value["queuecap"] = kant::JsonOutput::writeJson(queuecap);
            p->value["queuetimeout"] = kant::JsonOutput::writeJson(queuetimeout);
            p->value["grid"] = kant::JsonOutput::writeJson(grid);
            p->value["protocol"] = kant::JsonOutput::writeJson(protocol);
            p->value["handlegroup"] = kant::JsonOutput::writeJson(handlegroup);
            p->value["shmkey"] = kant::JsonOutput::writeJson(shmkey);
            p->value["shmcap"] = kant::JsonOutput::writeJson(shmcap);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(adapterName,pObj->value["adapterName"], true);
            kant::JsonInput::readJson(threadNum,pObj->value["threadNum"], true);
            kant::JsonInput::readJson(endpoint,pObj->value["endpoint"], true);
            kant::JsonInput::readJson(maxConnections,pObj->value["maxConnections"], true);
            kant::JsonInput::readJson(allowIp,pObj->value["allowIp"], true);
            kant::JsonInput::readJson(servant,pObj->value["servant"], true);
            kant::JsonInput::readJson(queuecap,pObj->value["queuecap"], true);
            kant::JsonInput::readJson(queuetimeout,pObj->value["queuetimeout"], true);
            kant::JsonInput::readJson(grid,pObj->value["grid"], true);
            kant::JsonInput::readJson(protocol,pObj->value["protocol"], false);
            kant::JsonInput::readJson(handlegroup,pObj->value["handlegroup"], false);
            kant::JsonInput::readJson(shmkey,pObj->value["shmkey"], false);
            kant::JsonInput::readJson(shmcap,pObj->value["shmcap"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(adapterName,"adapterName");
            _ds.display(threadNum,"threadNum");
            _ds.display(endpoint,"endpoint");
            _ds.display(maxConnections,"maxConnections");
            _ds.display(allowIp,"allowIp");
            _ds.display(servant,"servant");
            _ds.display(queuecap,"queuecap");
            _ds.display(queuetimeout,"queuetimeout");
            _ds.display(grid,"grid");
            _ds.display(protocol,"protocol");
            _ds.display(handlegroup,"handlegroup");
            _ds.display(shmkey,"shmkey");
            _ds.display(shmcap,"shmcap");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(adapterName, true);
            _ds.displaySimple(threadNum, true);
            _ds.displaySimple(endpoint, true);
            _ds.displaySimple(maxConnections, true);
            _ds.displaySimple(allowIp, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(queuecap, true);
            _ds.displaySimple(queuetimeout, true);
            _ds.displaySimple(grid, true);
            _ds.displaySimple(protocol, true);
            _ds.displaySimple(handlegroup, true);
            _ds.displaySimple(shmkey, true);
            _ds.displaySimple(shmcap, false);
            return _os;
        }
    public:
        std::string adapterName;
        std::string threadNum;
        std::string endpoint;
        kant::Int32 maxConnections;
        std::string allowIp;
        std::string servant;
        kant::Int32 queuecap;
        kant::Int32 queuetimeout;
        kant::Int32 grid;
        std::string protocol;
        std::string handlegroup;
        kant::Int32 shmkey;
        kant::Int32 shmcap;
    };
    inline bool operator==(const AdapterDescriptor&l, const AdapterDescriptor&r)
    {
        return l.adapterName == r.adapterName && l.threadNum == r.threadNum && l.endpoint == r.endpoint && l.maxConnections == r.maxConnections && l.allowIp == r.allowIp && l.servant == r.servant && l.queuecap == r.queuecap && l.queuetimeout == r.queuetimeout && l.grid == r.grid && l.protocol == r.protocol && l.handlegroup == r.handlegroup && l.shmkey == r.shmkey && l.shmcap == r.shmcap;
    }
    inline bool operator!=(const AdapterDescriptor&l, const AdapterDescriptor&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AdapterDescriptor&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AdapterDescriptor&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ServerDescriptor : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.ServerDescriptor";
        }
        static string MD5()
        {
            return "ff1ecd1dc7817b13c7b574a869280b84";
        }
        ServerDescriptor()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            application = "";
            serverName = "";
            nodeName = "";
            basePath = "";
            exePath = "";
            settingState = "";
            presentState = "";
            profile = "";
            patchVersion = "";
            patchTime = "";
            patchUser = "";
            adapters.clear();
            serverType = "";
            startScript = "";
            stopScript = "";
            monitorScript = "";
            configCenterPort = 0;
            asyncThreadNum = 0;
            setId = "";
            sJmx_port = "";
            runType = "";
            baseImage = "";
            sha = "";
            baseImageId = "";
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(application, 0);
            _os.write(serverName, 1);
            _os.write(nodeName, 2);
            _os.write(basePath, 3);
            _os.write(exePath, 4);
            _os.write(settingState, 5);
            _os.write(presentState, 6);
            _os.write(profile, 7);
            _os.write(patchVersion, 8);
            _os.write(patchTime, 9);
            _os.write(patchUser, 10);
            _os.write(adapters, 11);
            if (serverType != "")
            {
                _os.write(serverType, 12);
            }
            if (startScript != "")
            {
                _os.write(startScript, 13);
            }
            if (stopScript != "")
            {
                _os.write(stopScript, 14);
            }
            if (monitorScript != "")
            {
                _os.write(monitorScript, 15);
            }
            if (configCenterPort != 0)
            {
                _os.write(configCenterPort, 16);
            }
            if (asyncThreadNum != 0)
            {
                _os.write(asyncThreadNum, 17);
            }
            if (setId != "")
            {
                _os.write(setId, 18);
            }
            if (sJmx_port != "")
            {
                _os.write(sJmx_port, 19);
            }
            if (runType != "")
            {
                _os.write(runType, 20);
            }
            if (baseImage != "")
            {
                _os.write(baseImage, 21);
            }
            if (sha != "")
            {
                _os.write(sha, 22);
            }
            if (baseImageId != "")
            {
                _os.write(baseImageId, 23);
            }
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(application, 0, true);
            _is.read(serverName, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(basePath, 3, true);
            _is.read(exePath, 4, true);
            _is.read(settingState, 5, true);
            _is.read(presentState, 6, true);
            _is.read(profile, 7, true);
            _is.read(patchVersion, 8, true);
            _is.read(patchTime, 9, true);
            _is.read(patchUser, 10, true);
            _is.read(adapters, 11, true);
            _is.read(serverType, 12, false);
            _is.read(startScript, 13, false);
            _is.read(stopScript, 14, false);
            _is.read(monitorScript, 15, false);
            _is.read(configCenterPort, 16, false);
            _is.read(asyncThreadNum, 17, false);
            _is.read(setId, 18, false);
            _is.read(sJmx_port, 19, false);
            _is.read(runType, 20, false);
            _is.read(baseImage, 21, false);
            _is.read(sha, 22, false);
            _is.read(baseImageId, 23, false);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["application"] = kant::JsonOutput::writeJson(application);
            p->value["serverName"] = kant::JsonOutput::writeJson(serverName);
            p->value["nodeName"] = kant::JsonOutput::writeJson(nodeName);
            p->value["basePath"] = kant::JsonOutput::writeJson(basePath);
            p->value["exePath"] = kant::JsonOutput::writeJson(exePath);
            p->value["settingState"] = kant::JsonOutput::writeJson(settingState);
            p->value["presentState"] = kant::JsonOutput::writeJson(presentState);
            p->value["profile"] = kant::JsonOutput::writeJson(profile);
            p->value["patchVersion"] = kant::JsonOutput::writeJson(patchVersion);
            p->value["patchTime"] = kant::JsonOutput::writeJson(patchTime);
            p->value["patchUser"] = kant::JsonOutput::writeJson(patchUser);
            p->value["adapters"] = kant::JsonOutput::writeJson(adapters);
            p->value["serverType"] = kant::JsonOutput::writeJson(serverType);
            p->value["startScript"] = kant::JsonOutput::writeJson(startScript);
            p->value["stopScript"] = kant::JsonOutput::writeJson(stopScript);
            p->value["monitorScript"] = kant::JsonOutput::writeJson(monitorScript);
            p->value["configCenterPort"] = kant::JsonOutput::writeJson(configCenterPort);
            p->value["asyncThreadNum"] = kant::JsonOutput::writeJson(asyncThreadNum);
            p->value["setId"] = kant::JsonOutput::writeJson(setId);
            p->value["sJmx_port"] = kant::JsonOutput::writeJson(sJmx_port);
            p->value["runType"] = kant::JsonOutput::writeJson(runType);
            p->value["baseImage"] = kant::JsonOutput::writeJson(baseImage);
            p->value["sha"] = kant::JsonOutput::writeJson(sha);
            p->value["baseImageId"] = kant::JsonOutput::writeJson(baseImageId);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(application,pObj->value["application"], true);
            kant::JsonInput::readJson(serverName,pObj->value["serverName"], true);
            kant::JsonInput::readJson(nodeName,pObj->value["nodeName"], true);
            kant::JsonInput::readJson(basePath,pObj->value["basePath"], true);
            kant::JsonInput::readJson(exePath,pObj->value["exePath"], true);
            kant::JsonInput::readJson(settingState,pObj->value["settingState"], true);
            kant::JsonInput::readJson(presentState,pObj->value["presentState"], true);
            kant::JsonInput::readJson(profile,pObj->value["profile"], true);
            kant::JsonInput::readJson(patchVersion,pObj->value["patchVersion"], true);
            kant::JsonInput::readJson(patchTime,pObj->value["patchTime"], true);
            kant::JsonInput::readJson(patchUser,pObj->value["patchUser"], true);
            kant::JsonInput::readJson(adapters,pObj->value["adapters"], true);
            kant::JsonInput::readJson(serverType,pObj->value["serverType"], false);
            kant::JsonInput::readJson(startScript,pObj->value["startScript"], false);
            kant::JsonInput::readJson(stopScript,pObj->value["stopScript"], false);
            kant::JsonInput::readJson(monitorScript,pObj->value["monitorScript"], false);
            kant::JsonInput::readJson(configCenterPort,pObj->value["configCenterPort"], false);
            kant::JsonInput::readJson(asyncThreadNum,pObj->value["asyncThreadNum"], false);
            kant::JsonInput::readJson(setId,pObj->value["setId"], false);
            kant::JsonInput::readJson(sJmx_port,pObj->value["sJmx_port"], false);
            kant::JsonInput::readJson(runType,pObj->value["runType"], false);
            kant::JsonInput::readJson(baseImage,pObj->value["baseImage"], false);
            kant::JsonInput::readJson(sha,pObj->value["sha"], false);
            kant::JsonInput::readJson(baseImageId,pObj->value["baseImageId"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(basePath,"basePath");
            _ds.display(exePath,"exePath");
            _ds.display(settingState,"settingState");
            _ds.display(presentState,"presentState");
            _ds.display(profile,"profile");
            _ds.display(patchVersion,"patchVersion");
            _ds.display(patchTime,"patchTime");
            _ds.display(patchUser,"patchUser");
            _ds.display(adapters,"adapters");
            _ds.display(serverType,"serverType");
            _ds.display(startScript,"startScript");
            _ds.display(stopScript,"stopScript");
            _ds.display(monitorScript,"monitorScript");
            _ds.display(configCenterPort,"configCenterPort");
            _ds.display(asyncThreadNum,"asyncThreadNum");
            _ds.display(setId,"setId");
            _ds.display(sJmx_port,"sJmx_port");
            _ds.display(runType,"runType");
            _ds.display(baseImage,"baseImage");
            _ds.display(sha,"sha");
            _ds.display(baseImageId,"baseImageId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(basePath, true);
            _ds.displaySimple(exePath, true);
            _ds.displaySimple(settingState, true);
            _ds.displaySimple(presentState, true);
            _ds.displaySimple(profile, true);
            _ds.displaySimple(patchVersion, true);
            _ds.displaySimple(patchTime, true);
            _ds.displaySimple(patchUser, true);
            _ds.displaySimple(adapters, true);
            _ds.displaySimple(serverType, true);
            _ds.displaySimple(startScript, true);
            _ds.displaySimple(stopScript, true);
            _ds.displaySimple(monitorScript, true);
            _ds.displaySimple(configCenterPort, true);
            _ds.displaySimple(asyncThreadNum, true);
            _ds.displaySimple(setId, true);
            _ds.displaySimple(sJmx_port, true);
            _ds.displaySimple(runType, true);
            _ds.displaySimple(baseImage, true);
            _ds.displaySimple(sha, true);
            _ds.displaySimple(baseImageId, false);
            return _os;
        }
    public:
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string basePath;
        std::string exePath;
        std::string settingState;
        std::string presentState;
        std::string profile;
        std::string patchVersion;
        std::string patchTime;
        std::string patchUser;
        map<std::string, kant::AdapterDescriptor> adapters;
        std::string serverType;
        std::string startScript;
        std::string stopScript;
        std::string monitorScript;
        kant::Int32 configCenterPort;
        kant::Int32 asyncThreadNum;
        std::string setId;
        std::string sJmx_port;
        std::string runType;
        std::string baseImage;
        std::string sha;
        std::string baseImageId;
    };
    inline bool operator==(const ServerDescriptor&l, const ServerDescriptor&r)
    {
        return l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.basePath == r.basePath && l.exePath == r.exePath && l.settingState == r.settingState && l.presentState == r.presentState && l.profile == r.profile && l.patchVersion == r.patchVersion && l.patchTime == r.patchTime && l.patchUser == r.patchUser && l.adapters == r.adapters && l.serverType == r.serverType && l.startScript == r.startScript && l.stopScript == r.stopScript && l.monitorScript == r.monitorScript && l.configCenterPort == r.configCenterPort && l.asyncThreadNum == r.asyncThreadNum && l.setId == r.setId && l.sJmx_port == r.sJmx_port && l.runType == r.runType && l.baseImage == r.baseImage && l.sha == r.sha && l.baseImageId == r.baseImageId;
    }
    inline bool operator!=(const ServerDescriptor&l, const ServerDescriptor&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerDescriptor&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerDescriptor&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ObjectName : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.ObjectName";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        ObjectName()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            ObjectId = "";
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(ObjectId, 0);
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ObjectId, 0, true);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["ObjectId"] = kant::JsonOutput::writeJson(ObjectId);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(ObjectId,pObj->value["ObjectId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(ObjectId,"ObjectId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(ObjectId, false);
            return _os;
        }
    public:
        std::string ObjectId;
    };
    inline bool operator==(const ObjectName&l, const ObjectName&r)
    {
        return l.ObjectId == r.ObjectId;
    }
    inline bool operator!=(const ObjectName&l, const ObjectName&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ObjectName&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ObjectName&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ObjectItem : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.ObjectItem";
        }
        static string MD5()
        {
            return "2b7c303717e5b9f40d32612cd6b131ff";
        }
        ObjectItem()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            vActiveEndpoints.clear();
            vInactiveEndpoints.clear();
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(vActiveEndpoints, 0);
            _os.write(vInactiveEndpoints, 1);
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vActiveEndpoints, 0, true);
            _is.read(vInactiveEndpoints, 1, true);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["vActiveEndpoints"] = kant::JsonOutput::writeJson(vActiveEndpoints);
            p->value["vInactiveEndpoints"] = kant::JsonOutput::writeJson(vInactiveEndpoints);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(vActiveEndpoints,pObj->value["vActiveEndpoints"], true);
            kant::JsonInput::readJson(vInactiveEndpoints,pObj->value["vInactiveEndpoints"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(vActiveEndpoints,"vActiveEndpoints");
            _ds.display(vInactiveEndpoints,"vInactiveEndpoints");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(vActiveEndpoints, true);
            _ds.displaySimple(vInactiveEndpoints, false);
            return _os;
        }
    public:
        vector<kant::EndpointF> vActiveEndpoints;
        vector<kant::EndpointF> vInactiveEndpoints;
    };
    inline bool operator==(const ObjectItem&l, const ObjectItem&r)
    {
        return l.vActiveEndpoints == r.vActiveEndpoints && l.vInactiveEndpoints == r.vInactiveEndpoints;
    }
    inline bool operator!=(const ObjectItem&l, const ObjectItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ObjectItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ObjectItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ServerGroupRule : public kant::KantStructBase
    {
    public:
        static string className()
        {
            return "kant.ServerGroupRule";
        }
        static string MD5()
        {
            return "b4bfec89a82e67997930a31642bacca1";
        }
        ServerGroupRule()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            vGroupRuleInfo.clear();
        }
        template<typename WriterT>
        void writeTo(kant::KantOutputStream<WriterT>& _os) const
        {
            _os.write(vGroupRuleInfo, 0);
        }
        template<typename ReaderT>
        void readFrom(kant::KantInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vGroupRuleInfo, 0, true);
        }
        kant::JsonValueObjPtr writeToJson() const
        {
            kant::JsonValueObjPtr p = std::make_shared<kant::JsonValueObj>();
            p->value["vGroupRuleInfo"] = kant::JsonOutput::writeJson(vGroupRuleInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return kant::KT_Json::writeValue(writeToJson());
        }
        void readFromJson(const kant::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != kant::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw kant::KT_Json_Exception(s);
            }
            kant::JsonValueObjPtr pObj=std::dynamic_pointer_cast<kant::JsonValueObj>(p);
            kant::JsonInput::readJson(vGroupRuleInfo,pObj->value["vGroupRuleInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(kant::KT_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.display(vGroupRuleInfo,"vGroupRuleInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            kant::KantDisplayer _ds(_os, _level);
            _ds.displaySimple(vGroupRuleInfo, false);
            return _os;
        }
    public:
        vector<map<std::string, std::string> > vGroupRuleInfo;
    };
    inline bool operator==(const ServerGroupRule&l, const ServerGroupRule&r)
    {
        return l.vGroupRuleInfo == r.vGroupRuleInfo;
    }
    inline bool operator!=(const ServerGroupRule&l, const ServerGroupRule&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ServerGroupRule&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ServerGroupRule&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
